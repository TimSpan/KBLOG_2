<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>小程序-04 | KevinBlog</title>
    <meta name="description" content="小程序-04">
    <link rel="stylesheet" href="/KBLOG_2/assets/style.699c32a0.css">
    <link rel="modulepreload" href="/KBLOG_2/assets/Home.94f814a0.js">
    <link rel="modulepreload" href="/KBLOG_2/assets/app.bb1174c4.js">
    <link rel="modulepreload" href="/KBLOG_2/assets/posts_wechat-04.md.797aa61a.lean.js">
    
    <link rel="icon" type="image/png" href="/haimianbaobao.png">
  <meta name="author" content="Kevin">
  <meta property="og:title" content="Home">
  <meta property="og:description" content="Home of Kevin">
  <meta name="twitter:title" content="小程序-04 | KevinBlog">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><div class="no-sidebar theme"><header class="nav-bar" data-v-40587210><div class="sidebar-button" data-v-40587210><svg class="icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z" class></path></svg></div><a class="nav-bar-title" href="/KBLOG_2/" aria-label="KevinBlog, back to home" data-v-40587210 data-v-016a8bd8><img class="logo" src="/KBLOG_2/haimianbaobao.png" alt="Logo" data-v-016a8bd8> KevinBlog</a><div class="flex-grow" data-v-40587210></div><div class="nav" data-v-40587210><nav class="nav-links" data-v-40587210 data-v-35b91e7e><!--[--><div class="item" data-v-35b91e7e><div class="nav-link" data-v-35b91e7e data-v-49fe041d><a class="item" href="/KBLOG_2/" data-v-49fe041d>🏡Home <!----></a></div></div><div class="item" data-v-35b91e7e><div class="nav-link" data-v-35b91e7e data-v-49fe041d><a class="item" href="/KBLOG_2/tags" data-v-49fe041d>🔖Tags <!----></a></div></div><div class="item" data-v-35b91e7e><div class="nav-link" data-v-35b91e7e data-v-49fe041d><a class="item" href="/KBLOG_2/archives" data-v-49fe041d>📃Archives <!----></a></div></div><div class="item" data-v-35b91e7e><div class="nav-link" data-v-35b91e7e data-v-49fe041d><a class="item isExternal" href="https://vue3js.cn/interview/" target="_blank" rel="noopener noreferrer" data-v-49fe041d>面试官问系列 <svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15" data-v-49fe041d><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div></div><div class="item" data-v-35b91e7e><div class="nav-link" data-v-35b91e7e data-v-49fe041d><a class="item isExternal" href="https://www.yuque.com/cuggz/interview/gme0bw" target="_blank" rel="noopener noreferrer" data-v-49fe041d>语雀前端面试题总结 <svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15" data-v-49fe041d><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div></div><div class="item" data-v-35b91e7e><div class="nav-link" data-v-35b91e7e data-v-49fe041d><a class="item isExternal" href="https://www.html5iq.com/index.html" target="_blank" rel="noopener noreferrer" data-v-49fe041d>前端知识库 <svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15" data-v-49fe041d><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div></div><!--]--><!----><!----></nav></div><!--[--><!--[--><div class="toggleTheme" data-v-f68cd400><div class="light" data-v-f68cd400>🔆</div></div><!--]--><!--]--></header><aside class="sidebar" data-v-17c48e2f><nav class="nav-links nav" data-v-17c48e2f data-v-35b91e7e><!--[--><div class="item" data-v-35b91e7e><div class="nav-link" data-v-35b91e7e data-v-49fe041d><a class="item" href="/KBLOG_2/" data-v-49fe041d>🏡Home <!----></a></div></div><div class="item" data-v-35b91e7e><div class="nav-link" data-v-35b91e7e data-v-49fe041d><a class="item" href="/KBLOG_2/tags" data-v-49fe041d>🔖Tags <!----></a></div></div><div class="item" data-v-35b91e7e><div class="nav-link" data-v-35b91e7e data-v-49fe041d><a class="item" href="/KBLOG_2/archives" data-v-49fe041d>📃Archives <!----></a></div></div><div class="item" data-v-35b91e7e><div class="nav-link" data-v-35b91e7e data-v-49fe041d><a class="item isExternal" href="https://vue3js.cn/interview/" target="_blank" rel="noopener noreferrer" data-v-49fe041d>面试官问系列 <svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15" data-v-49fe041d><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div></div><div class="item" data-v-35b91e7e><div class="nav-link" data-v-35b91e7e data-v-49fe041d><a class="item isExternal" href="https://www.yuque.com/cuggz/interview/gme0bw" target="_blank" rel="noopener noreferrer" data-v-49fe041d>语雀前端面试题总结 <svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15" data-v-49fe041d><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div></div><div class="item" data-v-35b91e7e><div class="nav-link" data-v-35b91e7e data-v-49fe041d><a class="item isExternal" href="https://www.html5iq.com/index.html" target="_blank" rel="noopener noreferrer" data-v-49fe041d>前端知识库 <svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15" data-v-49fe041d><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div></div><!--]--><!----><!----></nav><!--[--><!--]--><!----><!--[--><!--]--></aside><div class="sidebar-mask"></div><main class="page" data-v-8fcebc32><div class="container" data-v-8fcebc32><!--[--><!--[--><!----><!--]--><!--[--><h1 class="title" data-v-cda39220></h1><div class="category" data-v-4c27e764><ul data-v-4c27e764><!--[--><li class="header" data-v-4c27e764><a href="#_1、自定义组件-组件的创建和引用" class="header-h1" data-v-4c27e764>1、自定义组件 - 组件的创建和引用</a><!----></li><li class="header" data-v-4c27e764><!----><ul data-v-4c27e764><li data-v-4c27e764><a href="#_1-1、创建组件" class="header-h2" data-v-4c27e764>1.1、创建组件</a></li></ul></li><li class="header" data-v-4c27e764><!----><ul data-v-4c27e764><li data-v-4c27e764><a href="#_1-2-、引用组件的方式" class="header-h2" data-v-4c27e764>1.2.、引用组件的方式</a></li></ul></li><li class="header" data-v-4c27e764><!----><ul data-v-4c27e764><li data-v-4c27e764><a href="#_1-3、局部引用组件" class="header-h2" data-v-4c27e764>1.3、局部引用组件</a></li></ul></li><li class="header" data-v-4c27e764><!----><ul data-v-4c27e764><li data-v-4c27e764><a href="#_1-4、全局引用组件" class="header-h2" data-v-4c27e764>1.4、全局引用组件</a></li></ul></li><li class="header" data-v-4c27e764><!----><ul data-v-4c27e764><li data-v-4c27e764><a href="#_1-5、-全局引用-vs-局部引用" class="header-h2" data-v-4c27e764>1.5、 全局引用 VS 局部引用</a></li></ul></li><li class="header" data-v-4c27e764><!----><ul data-v-4c27e764><li data-v-4c27e764><a href="#_1-6-、组件和页面的区别" class="header-h2" data-v-4c27e764>1.6.、组件和页面的区别</a></li></ul></li><li class="header" data-v-4c27e764><a href="#_2、自定义组件-样式" class="header-h1" data-v-4c27e764>2、自定义组件 - 样式</a><!----></li><li class="header" data-v-4c27e764><!----><ul data-v-4c27e764><li data-v-4c27e764><a href="#_2-1、组件样式隔离" class="header-h2" data-v-4c27e764>2.1、组件样式隔离</a></li></ul></li><li class="header" data-v-4c27e764><!----><ul data-v-4c27e764><li data-v-4c27e764><a href="#_2-2、组件样式隔离的注意点" class="header-h2" data-v-4c27e764>2.2、组件样式隔离的注意点</a></li></ul></li><li class="header" data-v-4c27e764><!----><ul data-v-4c27e764><li data-v-4c27e764><a href="#_2-3、修改组件的样式隔离选项" class="header-h2" data-v-4c27e764>2.3、修改组件的样式隔离选项</a></li></ul></li><li class="header" data-v-4c27e764><!----><ul data-v-4c27e764><li data-v-4c27e764><a href="#_2-4-、styleisolation-的可选值" class="header-h2" data-v-4c27e764>2.4.、styleIsolation 的可选值</a></li></ul></li><li class="header" data-v-4c27e764><a href="#_3、自定义组件-数据、方法、属性" class="header-h1" data-v-4c27e764>3、自定义组件 - 数据、方法、属性</a><!----></li><li class="header" data-v-4c27e764><!----><ul data-v-4c27e764><li data-v-4c27e764><a href="#_3-1、data数据" class="header-h2" data-v-4c27e764>3.1、data数据</a></li></ul></li><li class="header" data-v-4c27e764><!----><ul data-v-4c27e764><li data-v-4c27e764><a href="#_3-2、methods方法" class="header-h2" data-v-4c27e764>3.2、methods方法</a></li></ul></li><li class="header" data-v-4c27e764><!----><ul data-v-4c27e764><li data-v-4c27e764><a href="#_3-3、properties-属性" class="header-h2" data-v-4c27e764>3.3、properties 属性</a></li></ul></li><li class="header" data-v-4c27e764><!----><ul data-v-4c27e764><li data-v-4c27e764><a href="#_3-4、data-和-properties-的区别" class="header-h2" data-v-4c27e764>3.4、data 和 properties 的区别</a></li></ul></li><li class="header" data-v-4c27e764><!----><ul data-v-4c27e764><li data-v-4c27e764><a href="#_3-5、修改-properties-的值" class="header-h2" data-v-4c27e764>3.5、修改 properties 的值</a></li></ul></li><li class="header" data-v-4c27e764><a href="#_4、自定义组件-数据监听器" class="header-h1" data-v-4c27e764>4、自定义组件 - 数据监听器</a><!----></li><li class="header" data-v-4c27e764><a href="#_5、自定义组件-纯数据字段" class="header-h1" data-v-4c27e764>5、自定义组件 - 纯数据字段</a><!----></li><li class="header" data-v-4c27e764><a href="#_6、自定义组件-组件的生命周期" class="header-h1" data-v-4c27e764>6、自定义组件 - 组件的生命周期</a><!----></li><li class="header" data-v-4c27e764><!----><ul data-v-4c27e764><li data-v-4c27e764><a href="#_6-1、组件主要的生命周期函数" class="header-h2" data-v-4c27e764>6.1、组件主要的生命周期函数</a></li></ul></li><li class="header" data-v-4c27e764><!----><ul data-v-4c27e764><li data-v-4c27e764><a href="#_6-2、lifetimes节点" class="header-h2" data-v-4c27e764>6.2、lifetimes节点</a></li></ul></li><li class="header" data-v-4c27e764><!----><ul data-v-4c27e764><li data-v-4c27e764><a href="#_6-3、组件所在页面的生命周期" class="header-h2" data-v-4c27e764>6.3、组件所在页面的生命周期</a></li></ul></li><li class="header" data-v-4c27e764><a href="#_7、自定义组件-插槽" class="header-h1" data-v-4c27e764>7、自定义组件 - 插槽</a><!----></li><li class="header" data-v-4c27e764><!----><ul data-v-4c27e764><li data-v-4c27e764><a href="#_7-2、单个插槽" class="header-h2" data-v-4c27e764>7.2、单个插槽</a></li></ul></li><li class="header" data-v-4c27e764><!----><ul data-v-4c27e764><li data-v-4c27e764><a href="#_7-3、启用多个插槽" class="header-h2" data-v-4c27e764>7.3、启用多个插槽</a></li></ul></li><li class="header" data-v-4c27e764><!----><ul data-v-4c27e764><li data-v-4c27e764><a href="#_7-4、定义-多个插槽" class="header-h2" data-v-4c27e764>7.4、定义 多个插槽</a></li></ul></li><li class="header" data-v-4c27e764><a href="#_8、自定义组件-父子组件通信" class="header-h1" data-v-4c27e764>8、自定义组件 - 父子组件通信</a><!----></li><li class="header" data-v-4c27e764><!----><ul data-v-4c27e764><li data-v-4c27e764><a href="#_8-1、父子组件之间通信的-3-种方式" class="header-h2" data-v-4c27e764>8.1、父子组件之间通信的 3 种方式</a></li></ul></li><li class="header" data-v-4c27e764><!----><ul data-v-4c27e764><li data-v-4c27e764><a href="#_8-2-、属性绑定" class="header-h2" data-v-4c27e764>8.2.、属性绑定</a></li></ul></li><li class="header" data-v-4c27e764><!----><ul data-v-4c27e764><li data-v-4c27e764><a href="#_8-3、事件绑定" class="header-h2" data-v-4c27e764>8.3、事件绑定</a></li></ul></li><li class="header" data-v-4c27e764><!----><ul data-v-4c27e764><li data-v-4c27e764><a href="#_8-4、获取组件实例" class="header-h2" data-v-4c27e764>8.4、获取组件实例</a></li></ul></li><li class="header" data-v-4c27e764><a href="#_9、自定义组件-behaviors" class="header-h1" data-v-4c27e764>9、自定义组件 - behaviors</a><!----></li><li class="header" data-v-4c27e764><!----><ul data-v-4c27e764><li data-v-4c27e764><a href="#一、什么是-behaviors-behaviors？" class="header-h2" data-v-4c27e764>一、什么是 behaviors behaviors？</a></li></ul></li><li class="header" data-v-4c27e764><!----><ul data-v-4c27e764><li data-v-4c27e764><a href="#二、behaviors-的工作方式？" class="header-h2" data-v-4c27e764>二、behaviors 的工作方式？</a></li></ul></li><li class="header" data-v-4c27e764><!----><ul data-v-4c27e764><li data-v-4c27e764><a href="#三、创建-behaviors" class="header-h2" data-v-4c27e764>三、创建 behaviors</a></li></ul></li><li class="header" data-v-4c27e764><!----><ul data-v-4c27e764><li data-v-4c27e764><a href="#四、导入并使用-behavior" class="header-h2" data-v-4c27e764>四、导入并使用 behavior</a></li></ul></li><li class="header" data-v-4c27e764><!----><ul data-v-4c27e764><li data-v-4c27e764><a href="#五、behavior-中所有可用的节点" class="header-h2" data-v-4c27e764>五、behavior 中所有可用的节点</a></li></ul></li><li class="header" data-v-4c27e764><!----><ul data-v-4c27e764><li data-v-4c27e764><a href="#六、同名字段的覆盖和组合规则" class="header-h2" data-v-4c27e764>六、同名字段的覆盖和组合规则</a></li></ul></li><!--]--></ul></div><!--]--><!--]--><div style="position:relative;" class="content" data-v-8fcebc32><div><h1 id="小程序-04-自定义组件" tabindex="-1">小程序-04-自定义组件 <a class="header-anchor" href="#小程序-04-自定义组件" aria-hidden="true">#</a></h1><h2 id="_1、自定义组件-组件的创建和引用" tabindex="-1">1、自定义组件 - 组件的创建和引用 <a class="header-anchor" href="#_1、自定义组件-组件的创建和引用" aria-hidden="true">#</a></h2><h3 id="_1-1、创建组件" tabindex="-1">1.1、创建组件 <a class="header-anchor" href="#_1-1、创建组件" aria-hidden="true">#</a></h3><p>文件夹 点击 新建Component</p><p>键入组件的名称之后回车，会自动生成组件对应的 4 个文件，后缀名分别为 .js ， .json ， .wxml 和 .wxss</p><div class="tip custom-block"><p class="custom-block-title">注意</p><p>为了保证目录结构的清晰，建议把不同的组件，存放到单独目录中.</p></div><h3 id="_1-2-、引用组件的方式" tabindex="-1">1.2.、引用组件的方式 <a class="header-anchor" href="#_1-2-、引用组件的方式" aria-hidden="true">#</a></h3><p>组件的引用方式分为“局部引用”和“全局引用”，顾名思义：</p><ul><li>局部引用：组件只能在当前被引用的页面内使用</li><li>全局引用：组件可以在每个小程序页面中使用</li></ul><p>在页面的 .json 配置文件中引用组件的方式，叫做“局部引用”。示例代码如下：</p><h3 id="_1-3、局部引用组件" tabindex="-1">1.3、局部引用组件 <a class="header-anchor" href="#_1-3、局部引用组件" aria-hidden="true">#</a></h3><p>在页面的 .json 配置文件中引用组件的方式，叫做“局部引用”。示例代码如下：</p><div class="language-js"><pre><code><span class="token punctuation">{</span>
	<span class="token string">&quot;usingComponents&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
		<span class="token string">&quot;my-test1&quot;</span><span class="token operator">:</span> <span class="token string">&quot;/components/test/test&quot;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>其中 my-test1 就是组件使用时的<code>标签名</code>, 而 /components/test/test 就是<code>组件的路径</code></p><h3 id="_1-4、全局引用组件" tabindex="-1">1.4、全局引用组件 <a class="header-anchor" href="#_1-4、全局引用组件" aria-hidden="true">#</a></h3><p>在 app.json 全局配置文件中引用组件的方式，叫做“全局引用”。示例代码如下：</p><div class="language-js"><pre><code><span class="token string">&quot;usingComponents&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
	<span class="token string">&quot;my-test2&quot;</span><span class="token operator">:</span> <span class="token string">&quot;/components/test2/test2&quot;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="_1-5、-全局引用-vs-局部引用" tabindex="-1">1.5、 全局引用 VS 局部引用 <a class="header-anchor" href="#_1-5、-全局引用-vs-局部引用" aria-hidden="true">#</a></h3><p>根据组件的使用频率和范围，来选择合适的引用方式：</p><ul><li>如果某组件在多个页面中经常被用到，建议进行“全局引用”</li><li>如果某组件只在特定的页面中被用到，建议进行“局部引用”</li></ul><h3 id="_1-6-、组件和页面的区别" tabindex="-1">1.6.、组件和页面的区别 <a class="header-anchor" href="#_1-6-、组件和页面的区别" aria-hidden="true">#</a></h3><p>从表面来看，组件和页面都是由 .js 、 .json 、 .wxml 和 .wxss 这四个文件组成的。但是，组件和 页面的 .js 与 .json 文件有明显的不同：</p><ul><li>组件的 .json 文件中需要声明 &quot;component&quot;: true 属性</li><li>组件的 .js 文件中调用的是 Component() 函数 <ul><li>整个程序启动调用的是 App()</li><li>某个页面的渲染调用的是 Page()</li><li>某个组件的渲染调用的是 Component()</li></ul></li></ul><div class="tip custom-block"><p class="custom-block-title">注意</p><p>组件的事件处理函数需要定义到 methods 节点中</p></div><h2 id="_2、自定义组件-样式" tabindex="-1">2、自定义组件 - 样式 <a class="header-anchor" href="#_2、自定义组件-样式" aria-hidden="true">#</a></h2><h3 id="_2-1、组件样式隔离" tabindex="-1">2.1、组件样式隔离 <a class="header-anchor" href="#_2-1、组件样式隔离" aria-hidden="true">#</a></h3><p>默认情况下，自定义组件的样式只对当前组件生效，不会影响到组件之外的 UI 结构，如图所示：</p><p><img src="/KBLOG_2/assets/componentIMG.cd390da1.png" alt=""></p><ul><li>组件 A 的样式不会影响组件 C 的样式</li><li>组件 A 的样式不会影响小程序页面的样式</li><li>小程序页面的样式不会影响组件 A 和 C 的样式</li></ul><p>组件样式的隔离性的好处有：</p><ol><li>防止外界的样式影响组件内部的样式</li><li>防止组件的样式破坏外界的样式</li></ol><h3 id="_2-2、组件样式隔离的注意点" tabindex="-1">2.2、组件样式隔离的注意点 <a class="header-anchor" href="#_2-2、组件样式隔离的注意点" aria-hidden="true">#</a></h3><div class="tip custom-block"><p class="custom-block-title">注意点</p><ul><li><code>app.wxss</code> 中的全局样式对组件无效</li><li>只有 class 选择器会有样式隔离效果， id 选择器、属性选择器、标签选择器不受样式隔离的影 响</li></ul><p>建议：在组件和引用组件的页面中建议使用 class 选择器，</p><p>不要使用 id、属性、标签选择器！</p><p>因为在绝 大多数情况下, 我们希望组件的样式是隔离开的</p></div><h3 id="_2-3、修改组件的样式隔离选项" tabindex="-1">2.3、修改组件的样式隔离选项 <a class="header-anchor" href="#_2-3、修改组件的样式隔离选项" aria-hidden="true">#</a></h3><p>默认情况下，自定义组件的样式隔离特性能够防止组件内外样式互相干扰的问题。</p><p>但有时，我们希望在外界能够控制组件内部的样式，此时，可以通过 <code>styleIsolation</code> 修改组件的样 式隔离选项，用法如下：</p><div class="language-js"><pre><code><span class="token function">Component</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
	options<span class="token operator">:</span> <span class="token punctuation">{</span>
		<span class="token comment">// 默认值isolated: 代表启动样式隔离</span>
		<span class="token comment">// apply-shared: 代表页面wxss样式将影响自定义组件</span>
		<span class="token comment">// shared: 代表双向的影响</span>
		styleIsolation<span class="token operator">:</span> <span class="token string">&#39;apply-shared&#39;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment">// 或在组件的.json 文件中新增加如下配置</span>
<span class="token comment">// {</span>
<span class="token comment">// 	&quot;styleIsolation&quot;: &quot;isolated&quot;</span>
<span class="token comment">// }</span>
</code></pre></div><h3 id="_2-4-、styleisolation-的可选值" tabindex="-1">2.4.、<code>styleIsolation</code> 的可选值 <a class="header-anchor" href="#_2-4-、styleisolation-的可选值" aria-hidden="true">#</a></h3><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>isolated</td><td>是</td><td>表示启用样式隔离，在自定义组件内外，使用 class 指定的样式将不会相互影响</td></tr><tr><td>apply-shared</td><td>否</td><td>表示页面 wxss 样式将影响到自定义组件，但自定义组件 wxss 中指定的样式不会影响页面</td></tr><tr><td>shared</td><td>否</td><td>表示页面 wxss 样式将影响到自定义组件，自定义组件 wxss 中指定的样式也会影响页面和其他设置了 <code>apply-shared</code> 或 <code>shared</code> 的自定义组件</td></tr></tbody></table><h2 id="_3、自定义组件-数据、方法、属性" tabindex="-1">3、自定义组件 - 数据、方法、属性 <a class="header-anchor" href="#_3、自定义组件-数据、方法、属性" aria-hidden="true">#</a></h2><h3 id="_3-1、data数据" tabindex="-1">3.1、data数据 <a class="header-anchor" href="#_3-1、data数据" aria-hidden="true">#</a></h3><p>在小程序组件中，用于组件模板渲染的私有数据，需要定义到 data 节点中，</p><h3 id="_3-2、methods方法" tabindex="-1">3.2、methods方法 <a class="header-anchor" href="#_3-2、methods方法" aria-hidden="true">#</a></h3><p>在小程序组件中，事件处理函数和自定义方法需要定义到 methods 节点中</p><h3 id="_3-3、properties-属性" tabindex="-1">3.3、properties 属性 <a class="header-anchor" href="#_3-3、properties-属性" aria-hidden="true">#</a></h3><p>在小程序组件中， properties 是组件的对外属性，<strong>用来接收外界(父组件)传递到组件中的数据</strong>，示例 代码如下</p><div class="language-js"><pre><code>  <span class="token comment">// 属性定义</span>
  properties<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token comment">// 完整定义 属性的方式【当需要指定属性默认值时，建议使用此方式】</span>
    max<span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token comment">// 属性值的数据类型</span>
      type<span class="token operator">:</span> Number<span class="token punctuation">,</span>
      <span class="token comment">// 属性值的默认值</span>
      value<span class="token operator">:</span> <span class="token number">10</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token comment">// 简化定义 属性的方式</span>
    max<span class="token operator">:</span> Number
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
</code></pre></div><h3 id="_3-4、data-和-properties-的区别" tabindex="-1">3.4、data 和 properties 的区别 <a class="header-anchor" href="#_3-4、data-和-properties-的区别" aria-hidden="true">#</a></h3><p>在小程序的组件中， properties 属性和 data 数据的用法相同，它们都是可读可写的，只不过：</p><ul><li>data 更倾向于存储组件的私有数据</li><li>properties 更倾向于存储外界传递到组件中的数据 <ol><li>所以, 也不太建议修改 properties 数据</li><li>如果要修改 properties 的数据, 最好通过子组件通信给父组件的方式实现</li></ol></li></ul><h3 id="_3-5、修改-properties-的值" tabindex="-1">3.5、修改 properties 的值 <a class="header-anchor" href="#_3-5、修改-properties-的值" aria-hidden="true">#</a></h3><p>由于 data 数据和 properties 属性在本质上没有任何区别，因此 properties 属性的值也可以用于 页面渲染，或使用 setData 为 properties 中的属性重新赋值，示例代码如下：</p><div class="language-js"><pre><code>  <span class="token function">Component</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    properties<span class="token operator">:</span> <span class="token punctuation">{</span>
      max<span class="token operator">:</span> Number
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    methods<span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token function">addCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 使用 setData 修改属性的值</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setData</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
          max<span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>properties<span class="token punctuation">.</span>max <span class="token operator">+</span> <span class="token number">1</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><h2 id="_4、自定义组件-数据监听器" tabindex="-1">4、自定义组件 - 数据监听器 <a class="header-anchor" href="#_4、自定义组件-数据监听器" aria-hidden="true">#</a></h2><p>数据监听器用于监听和响应任何属性和数据字段的变化，从而执行特定的操作。 它的作用<code>类似于vue中的watch侦听器</code>。 在小程序组件中,数据监听器的基本语法格式如下：</p><div class="language-js"><pre><code>  <span class="token function">Components</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    <span class="token comment">// observers: 观察者</span>
    observers<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token string">&#39;字段A， 字段B&#39;</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">字段<span class="token constant">A</span>的新值， 字段<span class="token constant">B</span>的新值</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// do something</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>监听对象属性的变化:</p><p>数据监听器支持监听对象中单个或多个属性的变化，示例语法如下：</p><p>方式1: 普通方式</p><div class="language-js"><pre><code><span class="token function">Components</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token comment">// observers: 观察者</span>
  observers<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token string">&#39;对象.属性A， 对象.属性B&#39;</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">属性<span class="token constant">A</span>的新值， 属性<span class="token constant">B</span>的新值</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 触发此侦听器的 3 种情况：</span>
      <span class="token comment">// 【为属性A赋值】：使用setData 设置this.data.对象.属性A 时触发</span>
      <span class="token comment">// 【为属性B赋值】：使用setData 设置this.data.对象.属性B 时触发</span>
      <span class="token comment">// 【为对象赋值】：使用setData 设置this.data.对象 时触发</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>方式2: 通配符方式, 监听对象中所有属性的变化</p><div class="language-js"><pre><code>  observers<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token string">&#39;_rgb.**&#39;</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setData</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
        fullColor<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>obj<span class="token punctuation">.</span>r<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">, </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>obj<span class="token punctuation">.</span>g<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">, </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>obj<span class="token punctuation">.</span>b<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

</code></pre></div><h2 id="_5、自定义组件-纯数据字段" tabindex="-1">5、自定义组件 - 纯数据字段 <a class="header-anchor" href="#_5、自定义组件-纯数据字段" aria-hidden="true">#</a></h2><p><strong>概念</strong>：纯数据字段指的是那些不用于界面渲染的 data 字段。</p><p>应用场景：</p><p>例如有些情况下，某些 data 中的字段<strong>既不会展示在界面上</strong>，<strong>也不会传递给其他组件</strong>，<strong>仅仅在当前组件内部使用</strong>。带有这种特性的 data 字段适合被设置为<strong>纯数据字段</strong>。例如之前控制上拉加载更多的节 流阀 isLoading 这种类型的数据.</p><p>使用纯数据的好处:纯数据字段有助于<strong>提升页面更新的性能</strong>。</p><p>因为在小程序中， data 中声明的数据，会具备一个响应式的效果，系统的底层会对数据进行值变化的 监听，如果，该数据只是纯数据，没有必要进行响应式的监听，因此定义为纯数据能够提高页面的性能</p><p>2、使用规则</p><p>在 Component 构造器的 options 节点中，指定 pureDataPattern 为一个 正则表达式 ，字段名符合 这个正则</p><p>表达式的字段将会被视为纯数据字段，示例代码如下：</p><div class="language-js"><pre><code><span class="token function">Component</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  options<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token comment">// 指定所有_开头的数据字段为 纯数据字段</span>
    pureDataPattern<span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">^_</span><span class="token regex-delimiter">/</span></span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  data<span class="token operator">:</span> <span class="token punctuation">{</span>
    a<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token comment">// 普通数据字段</span>
    _b<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token comment">// 纯数据字段</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>3、使用纯数据字段改造数据监听器案例</p><div class="language-js"><pre><code><span class="token function">Component</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  options<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token comment">// 指定所有_开头的数据字段为 纯数据字段</span>
    pureDataPattern<span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">^_</span><span class="token regex-delimiter">/</span></span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  data<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token comment">// 将 rgb 改造为以 _开头的字段</span>
    _rgb<span class="token operator">:</span> <span class="token punctuation">{</span>
      r<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
      g<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
      b<span class="token operator">:</span> <span class="token number">0</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    fullColor<span class="token operator">:</span> <span class="token string">&#39;0, 0, 0&#39;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><h2 id="_6、自定义组件-组件的生命周期" tabindex="-1">6、自定义组件 - 组件的生命周期 <a class="header-anchor" href="#_6、自定义组件-组件的生命周期" aria-hidden="true">#</a></h2><p>小程序组件可用的全部生命周期如下表所示：</p><table><thead><tr><th>声明周期函数</th><th>参数</th><th>描述说明</th></tr></thead><tbody><tr><td><code>created</code></td><td>无</td><td><code>在组件实例刚刚被创建时执行</code></td></tr><tr><td><code>attached</code></td><td>无</td><td><code>在组件实例进入页面节点数时执行</code></td></tr><tr><td>ready</td><td>无</td><td>在组件在视图层布局完成后执行</td></tr><tr><td>moved</td><td>无</td><td>在组件实例被移动到节点数另一个位置时执行</td></tr><tr><td><code>detached</code></td><td>无</td><td><code>在组件实例从页面节点树移除时执行</code></td></tr><tr><td>error</td><td>Object Error</td><td>每当组件方法抛出错误时执行</td></tr></tbody></table><h3 id="_6-1、组件主要的生命周期函数" tabindex="-1">6.1、组件主要的生命周期函数 <a class="header-anchor" href="#_6-1、组件主要的生命周期函数" aria-hidden="true">#</a></h3><p>在小程序组件中，最重要的生命周期函数是 created 、 attached 、 ready 、 detached 。它们各自的 特点</p><p>① 组件实例刚被创建好的时候， created 生命周期函数会被触发</p><ul><li>此时调用 setData 不会有效果</li><li>通常在这个生命周期函数中，只应该用于给组件的 this 添加一些自定义的属性字段</li></ul><p>② 在组件完全初始化完毕、进入页面节点树后， attached 生命周期函数会被触发</p><ul><li>此时， this.data 已被初始化完毕</li><li>这个生命周期很有用，绝大多数初始化的工作可以在这个时机进行（例如发请求获取初始数据）</li></ul><p>③ 在组件离开页面节点树后， detached 生命周期函数会被触发</p><ul><li>退出一个页面时，会触发页面内每个自定义组件的 detached 生命周期函数</li><li>此时适合做一些清理性质的工作,例如,清除定时器</li></ul><p>④ 代表组件渲染完成的生命周期函数为 ready</p><ul><li>可以操作页面</li></ul><h3 id="_6-2、lifetimes节点" tabindex="-1">6.2、lifetimes节点 <a class="header-anchor" href="#_6-2、lifetimes节点" aria-hidden="true">#</a></h3><p>在小程序组件中，生命周期函数可以直接定义在 Component 构造器的第一级参数中，也可以在 lifetimes 字段内进行声明（这是推荐的方式，其优先级最高）。示例代码如下：</p><div class="language-js"><pre><code><span class="token function">Component</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token comment">// 推荐用法</span>
  lifetimes<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function">attached</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token comment">// 在组件实例进入页面节点树时执行</span>
    <span class="token function">detached</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token comment">// 在组建实例被从页面节点树移除时执行</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><h3 id="_6-3、组件所在页面的生命周期" tabindex="-1">6.3、组件所在页面的生命周期 <a class="header-anchor" href="#_6-3、组件所在页面的生命周期" aria-hidden="true">#</a></h3><p>什么是组件所在页面的生命周期？</p><p>有时，<strong>自定义组件的行为依赖于页面状态的变化</strong>，此时就需要用到组件所在页面的生命周期。</p><p>例如：每当触发页面的 show 生命周期函数的时候，我们希望能够重新生成一个随机的 RGB 颜色值。 在自定义组件中，组件所在页面的生命周期函数有如下 3 个，分别是：</p><table><thead><tr><th>生命周期函数</th><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>show</td><td>无</td><td>组件所在的页面被<code>展示</code>时执行</td></tr><tr><td>hide</td><td>无</td><td>组件所在的页面被<code>隐藏</code>时执行</td></tr><tr><td>resize</td><td>Object Size</td><td>组件所在的<code>页面尺寸变化</code>时执行</td></tr></tbody></table><p>所以组件所在页面的生命周期, 相当于在组件中, 监听了组件所在页面的一些事件.</p><p>6.4、pageLifetimes 节点</p><p>组件所在页面的生命周期函数，需要定义在 pageLifetimes 节点中，示例代码如下：</p><div class="language-js"><pre><code><span class="token function">Component</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token comment">// 组件在页面的生命周期函数在该节点定义</span>
  pageLifetimes<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token comment">// 页面被展示</span>
    <span class="token function">hide</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token comment">// 页面被隐藏</span>
    <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// 页面尺寸变化</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>我们可以利用组件所在页面的生命周期, 在页面每次被展示的时候, 随机生成 RGB 颜色值</p><div class="language-js"><pre><code><span class="token function">Component</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token comment">// 组件在页面的生命周期函数在该节点定义</span>
  pageLifetimes<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token comment">// 组件所在的页面被展示时，随机生成一个颜色值</span>
    <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setData</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
        _rgb<span class="token operator">:</span> <span class="token punctuation">{</span>
          r<span class="token operator">:</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">256</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
          g<span class="token operator">:</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">256</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
          b<span class="token operator">:</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">256</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">hide</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token comment">// 页面被隐藏</span>
    <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// 页面尺寸变化</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>或者这样,逻辑更清晰</p><div class="language-js"><pre><code><span class="token function">Component</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token comment">// 在组件的methods节点中，定义一个随机颜色的方法</span>
  methods<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function">_randomColor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 设置data中的数据</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setData</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
        _rgb<span class="token operator">:</span> <span class="token punctuation">{</span>
          r<span class="token operator">:</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">256</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
          g<span class="token operator">:</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">256</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
          b<span class="token operator">:</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">256</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token comment">// 在组件内部的pageLifetimes节点中，监听组件在页面的生命周期函数</span>
  pageLifetimes<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token comment">// 在页面被展示的时候，调用该方法</span>
    <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">_randomColor</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">hide</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token comment">// 页面被隐藏</span>
    <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// 页面尺寸变化</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><h2 id="_7、自定义组件-插槽" tabindex="-1">7、自定义组件 - 插槽 <a class="header-anchor" href="#_7、自定义组件-插槽" aria-hidden="true">#</a></h2><p>在自定义组件的 wxml 结构中，可以提供一个 节点（插槽），用于承载组件使用者提供的 wxml 结构。</p><p><img src="/KBLOG_2/assets/c2.83eefc52.png" alt=""></p><p>其实插槽, 说的通俗一些, 就是子组件挖坑，父组件填坑的过程。由父组件在使用子组件的时候, 决定子 组件内部的某一些布局展示</p><ul><li>子组件通过 挖坑</li><li>父组件通过组件标签中间的内容来填坑</li></ul><h3 id="_7-2、单个插槽" tabindex="-1">7.2、单个插槽 <a class="header-anchor" href="#_7-2、单个插槽" aria-hidden="true">#</a></h3><p>在小程序中，默认每个自定义组件中只允许使用一个 进行占位，这种个数上的限制叫做单个插槽。</p><p>自定义组件的布局代码</p><div class="language-html"><pre><code><span class="token comment">&lt;!-- 组件的封装者 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>view</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>wrapper<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>view</span><span class="token punctuation">&gt;</span></span>这里是组件的内部节点<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>view</span><span class="token punctuation">&gt;</span></span>
	<span class="token comment">&lt;!-- 对于不确定的内容，可以使用&lt;slot&gt; 进行占位， 具体内容由组件的使用者决定 --&gt;</span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>slot</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>slot</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>view</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><div class="language-html"><pre><code><span class="token comment">&lt;!-- 组件的使用者 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>component-tag-name</span><span class="token punctuation">&gt;</span></span>
	<span class="token comment">&lt;!-- 这部分内容将被放置在组件的 &lt;slot&gt;的位置上 --&gt;</span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>view</span><span class="token punctuation">&gt;</span></span>这里是插入到组件slot中的内容<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>view</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>component-tag-name</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><h3 id="_7-3、启用多个插槽" tabindex="-1">7.3、启用多个插槽 <a class="header-anchor" href="#_7-3、启用多个插槽" aria-hidden="true">#</a></h3><p>在小程序的自定义组件中，需要使用多 插槽时，可以在组件的 .js 文件中，通过如下方式进行启用。 示例代码如下：<strong>开启多个插槽的配置</strong></p><div class="language-js"><pre><code><span class="token function">Component</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  options<span class="token operator">:</span> <span class="token punctuation">{</span>
    multipleSolts<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token comment">// 在组件定义时的选项中启用多 slot支持</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  properties<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token comment">/* ...*/</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
  methods<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token comment">/* ...*/</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>一旦开启了多个插槽的配置, 就意味着在组件内部可能会有多个标签, 那我们在定义这多个标签的时候, 需要给每一个起名字.</p><p>而组件使用者在填充的时候, 需要指明填充哪一个</p><h3 id="_7-4、定义-多个插槽" tabindex="-1">7.4、定义 多个插槽 <a class="header-anchor" href="#_7-4、定义-多个插槽" aria-hidden="true">#</a></h3><p>可以在组件的 .wxml 中使用多个 标签，以不同的 name 来区分不同的插槽。示例代码如下：</p><div class="language-html"><pre><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>view</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>wrapper<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
	<span class="token comment">&lt;!-- name 为 before 的第一个 插槽 --&gt;</span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>slot</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>before<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>slot</span><span class="token punctuation">&gt;</span></span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>view</span><span class="token punctuation">&gt;</span></span>这是一段固定的文本内容<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>view</span><span class="token punctuation">&gt;</span></span>
	<span class="token comment">&lt;!-- name 为 after 的第一个 插槽 --&gt;</span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>slot</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>after<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>slot</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>view</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>在使用带有多个插槽的自定义组件时，需要用 slot 属性来将节点插入到不同的 中。示例代码如下：</p><div class="language-html"><pre><code><span class="token comment">&lt;!-- 组件的使用者 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>component-tag-name</span><span class="token punctuation">&gt;</span></span>
	<span class="token comment">&lt;!-- 这部分内容将被放置在组件的 &lt;slot&gt;的位置上 --&gt;</span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>view</span> <span class="token attr-name">slot</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>before<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>这是通过插槽填充的内容,name为before<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>view</span><span class="token punctuation">&gt;</span></span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>view</span> <span class="token attr-name">slot</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>after<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>这是通过插槽填充的内容,name为after<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>view</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>component-tag-name</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><h2 id="_8、自定义组件-父子组件通信" tabindex="-1">8、自定义组件 - 父子组件通信 <a class="header-anchor" href="#_8、自定义组件-父子组件通信" aria-hidden="true">#</a></h2><h3 id="_8-1、父子组件之间通信的-3-种方式" tabindex="-1">8.1、父子组件之间通信的 3 种方式 <a class="header-anchor" href="#_8-1、父子组件之间通信的-3-种方式" aria-hidden="true">#</a></h3><p>① 属性绑定</p><ul><li>用于父组件向子组件的指定属性设置数据，仅能设置 JSON 兼容的数据(只能传递数据，不能传递 方法)</li></ul><p>② 事件绑定</p><ul><li>用于子组件向父组件传递数据，可以传递任意数据(包括数据和方法)</li></ul><p>③ 获取组件实例</p><ul><li>父组件还可以通过 <code>this.selectComponent()</code> 获取子组件实例对象</li><li>这样就可以直接访问子组件的任意数据和方法</li></ul><h3 id="_8-2-、属性绑定" tabindex="-1">8.2.、属性绑定 <a class="header-anchor" href="#_8-2-、属性绑定" aria-hidden="true">#</a></h3><p>属性绑定用于实现父向子传值，而且只能传递普通类型的数据，无法将方法传递给子组件</p><div class="language-html"><pre><code>data: {
// 父组件中的data节点
	count: 0
}
// 父组件的wxml结构
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>my-test3</span> <span class="token attr-name">count</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>{{count}}<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>my-test3</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>view</span><span class="token punctuation">&gt;</span></span>------<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>view</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>view</span><span class="token punctuation">&gt;</span></span>父组件中，count值为 {{count}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>view</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>子组件在 properties 节点中声明对应的属性并使用。示例代码如下：</p><div class="language-html"><pre><code>// 子组件的properties 节点
properties: {
	count: Number
}
// 子组件的wxml结构
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>text</span><span class="token punctuation">&gt;</span></span>子组件中， count值为：{{count}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>text</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><h3 id="_8-3、事件绑定" tabindex="-1">8.3、事件绑定 <a class="header-anchor" href="#_8-3、事件绑定" aria-hidden="true">#</a></h3><p>事件绑定用于实现子向父传值，可以传递任何类型的数据。使用步骤如下：</p><p>① 在子组件的 js 中，在特定的时机通过调用 this.triggerEvent (&#39;自定义事件名称&#39;, { /* 参数对象 */ })产生一个自定义事件, 并且可以带上事件参数对象.</p><p>② 在父组件的 wxml 中的子组件标签中，使用 bind :自定义事件名称=&quot;事件处理函数&quot;监听自定义事 件。</p><p>③ 在父组件的 js 中，定义一个函数，这个函数即将通过自定义事件的形式，传递给子组件</p><p>④ 在父组件的 事件处理函数中，通过 e.detail 获取到子组件传递过来的数据</p><p>具体的代码如下:</p><blockquote><p>步骤1：在子组件的 js 中，在特定的时机通过调用 this.triggerEvent 产生一个自定义事件</p></blockquote><div class="language-html"><pre><code>// 子组件中的 wxml结构
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>text</span><span class="token punctuation">&gt;</span></span>子组件中，count值为: {{count}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>text</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">bindtap</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>addCount<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>+1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>

</code></pre></div><div class="language-js"><pre><code>  <span class="token comment">// 子组件中的js代码</span>
  methods<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function">addCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// this.setData这行代码写的很多此一举</span>
      <span class="token comment">// 因为只要父组件修改了它传递到子组件的数据, 子组件自然就随之进行更新了</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setData</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
        count<span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>properties<span class="token punctuation">.</span>count <span class="token operator">+</span> <span class="token number">1</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span>
      <span class="token comment">// 使用 this.triggerEvent去触发父组件的自定义事件</span>
      <span class="token comment">// 并将数值同步给父组件</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">tiggerEvent</span><span class="token punctuation">(</span><span class="token string">&#39;sync&#39;</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
        value<span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>properties<span class="token punctuation">.</span>count
      <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
</code></pre></div><p>步骤2：在父组件的 wxml 中的子组件标签中，使用 bind :自定义事件名称=“事件处理函数”监听 自定义事件</p><div class="language-html"><pre><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>my-test3</span> <span class="token attr-name">count</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>{{count}}<span class="token punctuation">&quot;</span></span> <span class="token attr-name"><span class="token namespace">bind:</span>sync</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>syncCount<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>my-test3</span><span class="token punctuation">&gt;</span></span>

</code></pre></div><p>步骤3：在父组件的 js 中，定义一个函数，这个函数在自定义事件产生的时候, 会得到执行</p><div class="language-js"><pre><code><span class="token comment">// 在父组件的JS文件中，定义一个事件</span>
<span class="token function">syncCount</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>步骤4：在父组件的 js 中，通过 e.detail 获取到子组件传递过来的数据。</p><div class="language-js"><pre><code><span class="token comment">// 父组件的js文件</span>
<span class="token function">syncCount</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setData</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
<span class="token comment">// 父组件通过事件对象 e 获取到子组件传递的值</span>
		count<span class="token operator">:</span> e<span class="token punctuation">.</span>detail<span class="token punctuation">.</span>value
	<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="_8-4、获取组件实例" tabindex="-1">8.4、获取组件实例 <a class="header-anchor" href="#_8-4、获取组件实例" aria-hidden="true">#</a></h3><p>可在父组件里调用 this.selectComponent(&quot;id或class选择器&quot;) ，获取子组件的实例对象，从而直 接访问子组件的任意数据和方法。调用时需要传入一个选择器，例如 this.selectComponent(&quot;.mycomponent&quot;) 。</p><div class="language-html"><pre><code><span class="token comment">&lt;!--
父组件的wxml文件
使用 bind:自定义事件名称（推荐: 结构清晰
--&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>my-test</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>cusstomA<span class="token punctuation">&quot;</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>cA<span class="token punctuation">&quot;</span></span> <span class="token attr-name">count</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>{{count}}<span class="token punctuation">&quot;</span></span> <span class="token attr-name"><span class="token namespace">bind:</span>sync</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>syncCount<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>my-test</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">bindtap</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>getChild<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>获取子组件实例<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><div class="language-js"><pre><code>    <span class="token comment">//父组件的js文件 按钮的tap事件处理函数</span>
    <span class="token function">getChild</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 切记下面的参数不能传递标签选择器，不然返回的是null</span>
      <span class="token comment">// 也可以传递ID选择器</span>
      <span class="token keyword">const</span> child <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">selectComponent</span><span class="token punctuation">(</span><span class="token string">&#39;.customA&#39;</span><span class="token punctuation">)</span>
      <span class="token comment">// 调用子组件的setData方法，修改count的值，</span>
      child<span class="token punctuation">.</span><span class="token function">setData</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
        count<span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>data<span class="token punctuation">.</span>count <span class="token operator">+</span> <span class="token number">1</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span>
      child<span class="token punctuation">.</span><span class="token function">addCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 直接调用子组件的addCount方法，该方法在child实例对象的</span>
      __proto__上可以访问到该方法
    <span class="token punctuation">}</span>
    <span class="token comment">// 这里的代码其实有点问题, 因为count的数据是属于父组件的, 并且由父组件通过自定义属性传递</span>
    <span class="token comment">// 给了子组件,</span>
    <span class="token comment">// 如果想修改这个count的值,</span>
    <span class="token comment">// 直接在父组件中修改即可,</span>
    <span class="token comment">// 子组件自动就能更新.完全没有</span>
    <span class="token comment">// 必要再这种场景下去修改子组件中count的值</span>
</code></pre></div><h2 id="_9、自定义组件-behaviors" tabindex="-1">9、自定义组件 - behaviors <a class="header-anchor" href="#_9、自定义组件-behaviors" aria-hidden="true">#</a></h2><h3 id="一、什么是-behaviors-behaviors？" tabindex="-1">一、什么是 behaviors behaviors？ <a class="header-anchor" href="#一、什么是-behaviors-behaviors？" aria-hidden="true">#</a></h3><p>是小程序中，用于实现组件间代码共享的特性，类似于 Vue.js 中的 “mixins” 。</p><h3 id="二、behaviors-的工作方式？" tabindex="-1">二、behaviors 的工作方式？ <a class="header-anchor" href="#二、behaviors-的工作方式？" aria-hidden="true">#</a></h3><p>每个 behaviors 可以包含一组属性、数据、生命周期函数和方法。组件引用它时，它的属性、数据和 方法会被合并到组件中。</p><p>每个组件可以引用多个 behaviors ， behaviors 也可以引用其它 behaviors 。</p><p>只有当组件共享的代码就可以使用 behaviors 来共享，如果是组件私有的代码，就不需要放在 behaviors 中</p><h3 id="三、创建-behaviors" tabindex="-1">三、创建 behaviors <a class="header-anchor" href="#三、创建-behaviors" aria-hidden="true">#</a></h3><p>调用 Behavior(Object object) 方法即可创建一个共享的 behavior 实例对象，供所有的组件使 用：</p><ul><li>创建一个文件夹 behaviors</li><li>新建 js 文件 my-behavior.js</li><li>在该文件中书写以下代码</li></ul><div class="language-js"><pre><code><span class="token comment">// 调用 Behavior()方法， 创建实例对象</span>
<span class="token comment">// 并使用 module.exports 将 behavior 实例对象共享出去</span>
module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token function">Behavior</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token comment">// 属性节点</span>
  properties<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token comment">// 私有数据节点</span>
  data<span class="token operator">:</span> <span class="token punctuation">{</span>
    username<span class="token operator">:</span> <span class="token string">&#39;zs&#39;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token comment">// 事件处理函数和自定义方法节点</span>
  methods<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token comment">// 其他节点...</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><h3 id="四、导入并使用-behavior" tabindex="-1">四、导入并使用 behavior <a class="header-anchor" href="#四、导入并使用-behavior" aria-hidden="true">#</a></h3><p>在组件中，使用 require() 方法导入需要的 behavior ，挂载后即可访问 behavior 中的数据或方 法，示例代码：</p><div class="language-js"><pre><code><span class="token comment">// 1.使用 required() 导入需要的自定义 behavior 模块</span>
<span class="token keyword">const</span> myBehavior <span class="token operator">=</span> <span class="token function">required</span><span class="token punctuation">(</span><span class="token string">&quot;../../behaviors/my-behavior&quot;</span><span class="token punctuation">)</span>
<span class="token comment">// 2.将导入的behavior 实例对象， 挂载在 behaviors 数组节点中， 即可生效</span>
<span class="token function">Component</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token comment">// 在组件内部 与data节点平级的位置定义该属性，挂载behavior模块</span>
  behaviors<span class="token operator">:</span> <span class="token punctuation">[</span>myBehavior<span class="token punctuation">]</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><div class="language-html"><pre><code>// 3.在子组件中使用behavior中的东西
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>view</span><span class="token punctuation">&gt;</span></span>在组件中共享的behavior是： {{username}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>view</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><div class="tip custom-block"><p class="custom-block-title">注意</p><p>注意： Behaviors 就仅仅只是做代码的复用而已，如果多个组件导入了同一种Behaviors，他们的数据 是相互独立的。</p></div><h3 id="五、behavior-中所有可用的节点" tabindex="-1">五、behavior 中所有可用的节点 <a class="header-anchor" href="#五、behavior-中所有可用的节点" aria-hidden="true">#</a></h3><table><thead><tr><th style="text-align:left;">定义段</th><th style="text-align:left;">类型</th><th style="text-align:left;">是否必填</th><th style="text-align:left;">描述</th><th style="text-align:left;">最低版本</th></tr></thead><tbody><tr><td style="text-align:left;">properties</td><td style="text-align:left;">Object Map</td><td style="text-align:left;">否</td><td style="text-align:left;">组件的对外属性，是属性名到属性设置的映射表</td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">data</td><td style="text-align:left;">Object</td><td style="text-align:left;">否</td><td style="text-align:left;">组件的内部数据，和 <code>properties</code> 一同用于组件的模板渲染</td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">observers</td><td style="text-align:left;">Object</td><td style="text-align:left;">否</td><td style="text-align:left;">组件数据字段监听器，用于监听 properties 和 data 的变化，参见 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/observer.html" target="_blank" rel="noopener noreferrer">数据监听器</a></td><td style="text-align:left;"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" target="_blank" rel="noopener noreferrer">2.6.1</a></td></tr><tr><td style="text-align:left;">methods</td><td style="text-align:left;">Object</td><td style="text-align:left;">否</td><td style="text-align:left;">组件的方法，包括事件响应函数和任意的自定义方法，关于事件响应函数的使用，参见 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/events.html" target="_blank" rel="noopener noreferrer">组件间通信与事件</a></td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">behaviors</td><td style="text-align:left;">String Array</td><td style="text-align:left;">否</td><td style="text-align:left;">类似于 mixins 和traits的组件间代码复用机制，参见 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/behaviors.html" target="_blank" rel="noopener noreferrer">behaviors</a></td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">created</td><td style="text-align:left;">Function</td><td style="text-align:left;">否</td><td style="text-align:left;">组件生命周期函数 - 在组件实例刚刚被创建时执行，注意此时不能调用 <code>setData</code> )</td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">attached</td><td style="text-align:left;">Function</td><td style="text-align:left;">否</td><td style="text-align:left;">组件生命周期函数 - 在组件实例进入页面节点树时执行)</td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">ready</td><td style="text-align:left;">Function</td><td style="text-align:left;">否</td><td style="text-align:left;">组件生命周期函数 - 在组件布局完成后执行)</td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">moved</td><td style="text-align:left;">Function</td><td style="text-align:left;">否</td><td style="text-align:left;">组件生命周期函数 - 在组件实例被移动到节点树另一个位置时执行)</td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">detached</td><td style="text-align:left;">Function</td><td style="text-align:left;">否</td><td style="text-align:left;">组件生命周期函数 - 在组件实例被从页面节点树移除时执行)</td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">relations</td><td style="text-align:left;">Object</td><td style="text-align:left;">否</td><td style="text-align:left;">组件间关系定义，参见 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/relations.html" target="_blank" rel="noopener noreferrer">组件间关系</a></td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">lifetimes</td><td style="text-align:left;">Object</td><td style="text-align:left;">否</td><td style="text-align:left;">组件生命周期声明对象，参见 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/lifetimes.html" target="_blank" rel="noopener noreferrer">组件生命周期</a></td><td style="text-align:left;"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" target="_blank" rel="noopener noreferrer">2.2.3</a></td></tr><tr><td style="text-align:left;">pageLifetimes</td><td style="text-align:left;">Object</td><td style="text-align:left;">否</td><td style="text-align:left;">组件所在页面的生命周期声明对象，参见 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/lifetimes.html" target="_blank" rel="noopener noreferrer">组件生命周期</a></td><td style="text-align:left;"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" target="_blank" rel="noopener noreferrer">2.2.3</a></td></tr><tr><td style="text-align:left;">definitionFilter</td><td style="text-align:left;">Function</td><td style="text-align:left;">否</td><td style="text-align:left;">定义段过滤器，用于自定义组件扩展，参见 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/extend.html" target="_blank" rel="noopener noreferrer">自定义组件扩展</a></td><td style="text-align:left;"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" target="_blank" rel="noopener noreferrer">2.2.3</a></td></tr></tbody></table><h3 id="六、同名字段的覆盖和组合规则" tabindex="-1">六、同名字段的覆盖和组合规则 <a class="header-anchor" href="#六、同名字段的覆盖和组合规则" aria-hidden="true">#</a></h3><p>组件和它引用的 behavior 中可以包含同名的字段，此时可以参考如下 3 种同名时的处理规则：</p><p>① 同名的数据字段 ( data )</p><p>② 同名的属性 ( properties ) 或方法 ( methods )</p><p>③ 同名的生命周期函数</p><p>关于详细的覆盖和组合规则，大家可以参考微信小程序官方文档给出的说明：</p></div></div><footer class="page-footer" data-v-8fcebc32 data-v-5c96fb00><div class="edit" data-v-5c96fb00><div class="edit-link" data-v-5c96fb00 data-v-55695e90><!----></div></div><div class="updated" data-v-5c96fb00><!----></div></footer><!----><!--[--><!--[--><!----><!--]--><!--[--><!----><!--]--><!--]--></div></main></div><!----><!--]--><footer data-v-c1f40558> Copyright © 2019-2022 | MIT License </footer><!--]--></div>
    <script>__VP_HASH_MAP__ = JSON.parse("{\"readme.md\":\"849cd169\",\"archives.md\":\"485d3d9f\",\"index.md\":\"5413b965\",\"posts_ajax.md\":\"d41fb002\",\"posts_git.md\":\"51bcdb97\",\"posts_react.md\":\"fbe7f0cb\",\"posts_es6模块化.md\":\"5261bc18\",\"posts_npm使用手册.md\":\"d8061f3c\",\"posts_npm命令发生的事.md\":\"4f1129ec\",\"posts_vue3快速上手.md\":\"cdeb2953\",\"posts_wechat-01.md\":\"c170829a\",\"posts_wechat-02.md\":\"cb7ff986\",\"posts_wechat-03.md\":\"fe0d55d5\",\"posts_wechat-04.md\":\"797aa61a\",\"posts_wechat-05.md\":\"10d2a821\",\"posts_前端常见面试题总结.md\":\"7cf35d1e\",\"posts_吴雨豪面试题详解.md\":\"c98758c7\",\"posts_微信小程序封装请求响应拦截器.md\":\"994e234a\",\"posts_第二次面试问题：.md\":\"9e3ebcd4\",\"tags.md\":\"ab596d1b\"}")</script>
    <script type="module" async src="/KBLOG_2/assets/app.bb1174c4.js"></script>
    
  </body>
</html>