<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>前端三剑客面试题 | KevinBlog</title>
    <meta name="description" content="前端三剑客面试题">
    <link rel="stylesheet" href="/KBLOG_2/assets/style.699c32a0.css">
    <link rel="modulepreload" href="/KBLOG_2/assets/Home.aa3234f5.js">
    <link rel="modulepreload" href="/KBLOG_2/assets/app.d3efa65c.js">
    <link rel="modulepreload" href="/KBLOG_2/assets/posts_前端三件套面试题.md.06e57df2.lean.js">
    
    <link rel="icon" type="image/png" href="/haimianbaobao.png">
  <meta name="author" content="Kevin">
  <meta property="og:title" content="Home">
  <meta property="og:description" content="Home of Kevin">
  <meta name="twitter:title" content="前端三剑客面试题 | KevinBlog">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><div class="no-sidebar theme"><header class="nav-bar" data-v-40587210><div class="sidebar-button" data-v-40587210><svg class="icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z" class></path></svg></div><a class="nav-bar-title" href="/KBLOG_2/" aria-label="KevinBlog, back to home" data-v-40587210 data-v-016a8bd8><img class="logo" src="/KBLOG_2/haimianbaobao.png" alt="Logo" data-v-016a8bd8> KevinBlog</a><div class="flex-grow" data-v-40587210></div><div class="nav" data-v-40587210><nav class="nav-links" data-v-40587210 data-v-35b91e7e><!--[--><div class="item" data-v-35b91e7e><div class="nav-link" data-v-35b91e7e data-v-49fe041d><a class="item" href="/KBLOG_2/" data-v-49fe041d>🏡Home <!----></a></div></div><div class="item" data-v-35b91e7e><div class="nav-link" data-v-35b91e7e data-v-49fe041d><a class="item" href="/KBLOG_2/tags" data-v-49fe041d>🔖Tags <!----></a></div></div><div class="item" data-v-35b91e7e><div class="nav-link" data-v-35b91e7e data-v-49fe041d><a class="item" href="/KBLOG_2/archives" data-v-49fe041d>📃Archives <!----></a></div></div><div class="item" data-v-35b91e7e><div class="nav-link" data-v-35b91e7e data-v-49fe041d><a class="item isExternal" href="https://vue3js.cn/interview/" target="_blank" rel="noopener noreferrer" data-v-49fe041d>面试官问系列 <svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15" data-v-49fe041d><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div></div><div class="item" data-v-35b91e7e><div class="nav-link" data-v-35b91e7e data-v-49fe041d><a class="item isExternal" href="https://www.yuque.com/cuggz/interview/gme0bw" target="_blank" rel="noopener noreferrer" data-v-49fe041d>语雀前端面试题总结 <svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15" data-v-49fe041d><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div></div><div class="item" data-v-35b91e7e><div class="nav-link" data-v-35b91e7e data-v-49fe041d><a class="item isExternal" href="https://www.html5iq.com/index.html" target="_blank" rel="noopener noreferrer" data-v-49fe041d>前端知识库 <svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15" data-v-49fe041d><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div></div><!--]--><!----><!----></nav></div><!--[--><!--[--><div class="toggleTheme" data-v-f68cd400><div class="light" data-v-f68cd400>🔆</div></div><!--]--><!--]--></header><aside class="sidebar" data-v-17c48e2f><nav class="nav-links nav" data-v-17c48e2f data-v-35b91e7e><!--[--><div class="item" data-v-35b91e7e><div class="nav-link" data-v-35b91e7e data-v-49fe041d><a class="item" href="/KBLOG_2/" data-v-49fe041d>🏡Home <!----></a></div></div><div class="item" data-v-35b91e7e><div class="nav-link" data-v-35b91e7e data-v-49fe041d><a class="item" href="/KBLOG_2/tags" data-v-49fe041d>🔖Tags <!----></a></div></div><div class="item" data-v-35b91e7e><div class="nav-link" data-v-35b91e7e data-v-49fe041d><a class="item" href="/KBLOG_2/archives" data-v-49fe041d>📃Archives <!----></a></div></div><div class="item" data-v-35b91e7e><div class="nav-link" data-v-35b91e7e data-v-49fe041d><a class="item isExternal" href="https://vue3js.cn/interview/" target="_blank" rel="noopener noreferrer" data-v-49fe041d>面试官问系列 <svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15" data-v-49fe041d><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div></div><div class="item" data-v-35b91e7e><div class="nav-link" data-v-35b91e7e data-v-49fe041d><a class="item isExternal" href="https://www.yuque.com/cuggz/interview/gme0bw" target="_blank" rel="noopener noreferrer" data-v-49fe041d>语雀前端面试题总结 <svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15" data-v-49fe041d><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div></div><div class="item" data-v-35b91e7e><div class="nav-link" data-v-35b91e7e data-v-49fe041d><a class="item isExternal" href="https://www.html5iq.com/index.html" target="_blank" rel="noopener noreferrer" data-v-49fe041d>前端知识库 <svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15" data-v-49fe041d><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div></div><!--]--><!----><!----></nav><!--[--><!--]--><!----><!--[--><!--]--></aside><div class="sidebar-mask"></div><main class="page" data-v-8fcebc32><div class="container" data-v-8fcebc32><!--[--><!--[--><!----><!--]--><!--[--><h1 class="title" data-v-cda39220></h1><div class="category" data-v-4c27e764><ul data-v-4c27e764><!--[--><li class="header" data-v-4c27e764><a href="#html" class="header-h1" data-v-4c27e764>html</a><!----></li><li class="header" data-v-4c27e764><!----><ul data-v-4c27e764><li data-v-4c27e764><a href="#src和href的区别" class="header-h2" data-v-4c27e764>src和href的区别</a></li></ul></li><li class="header" data-v-4c27e764><!----><ul data-v-4c27e764><li data-v-4c27e764><a href="#对html语义化的理解" class="header-h2" data-v-4c27e764>对HTML语义化的理解</a></li></ul></li><li class="header" data-v-4c27e764><!----><ul data-v-4c27e764><li data-v-4c27e764><a href="#doctype-⽂档类型-的作⽤" class="header-h2" data-v-4c27e764>DOCTYPE(⽂档类型) 的作⽤</a></li></ul></li><li class="header" data-v-4c27e764><!----><ul data-v-4c27e764><li data-v-4c27e764><a href="#常⽤的meta标签有哪些" class="header-h2" data-v-4c27e764>常⽤的meta标签有哪些</a></li></ul></li><li class="header" data-v-4c27e764><!----><ul data-v-4c27e764><li data-v-4c27e764><a href="#title与h1的区别、b与strong的区别、i与em的区别？" class="header-h2" data-v-4c27e764>title与h1的区别、b与strong的区别、i与em的区别？</a></li></ul></li><li class="header" data-v-4c27e764><!----><ul data-v-4c27e764><li data-v-4c27e764><a href="#label-的作用是什么？如何使用？" class="header-h2" data-v-4c27e764>label 的作用是什么？如何使用？</a></li></ul></li><li class="header" data-v-4c27e764><!----><ul data-v-4c27e764><li data-v-4c27e764><a href="#浏览器乱码的原因是什么？如何解决？" class="header-h2" data-v-4c27e764>浏览器乱码的原因是什么？如何解决？</a></li></ul></li><li class="header" data-v-4c27e764><!----><ul data-v-4c27e764><li data-v-4c27e764><a href="#渐进增强和优雅降级之间的区别" class="header-h2" data-v-4c27e764>渐进增强和优雅降级之间的区别</a></li></ul></li><li class="header" data-v-4c27e764><a href="#css" class="header-h1" data-v-4c27e764>css</a><!----></li><li class="header" data-v-4c27e764><!----><ul data-v-4c27e764><li data-v-4c27e764><a href="#隐藏元素的方法有哪些" class="header-h2" data-v-4c27e764>隐藏元素的方法有哪些</a></li></ul></li><li class="header" data-v-4c27e764><!----><ul data-v-4c27e764><li data-v-4c27e764><a href="#transition和animation的区别" class="header-h2" data-v-4c27e764>transition和animation的区别</a></li></ul></li><li class="header" data-v-4c27e764><!----><ul data-v-4c27e764><li data-v-4c27e764><a href="#link和-import的区别" class="header-h2" data-v-4c27e764>link和@import的区别</a></li></ul></li><li class="header" data-v-4c27e764><!----><ul data-v-4c27e764><li data-v-4c27e764><a href="#display-none与visibility-hidden的区别" class="header-h2" data-v-4c27e764>display:none与visibility:hidden的区别</a></li></ul></li><li class="header" data-v-4c27e764><!----><ul data-v-4c27e764><li data-v-4c27e764><a href="#伪元素和伪类的区别和作用？" class="header-h2" data-v-4c27e764>伪元素和伪类的区别和作用？</a></li></ul></li><li class="header" data-v-4c27e764><!----><ul data-v-4c27e764><li data-v-4c27e764><a href="#为什么有时候⽤translate来改变位置⽽不是定位？" class="header-h2" data-v-4c27e764>为什么有时候⽤translate来改变位置⽽不是定位？</a></li></ul></li><li class="header" data-v-4c27e764><!----><ul data-v-4c27e764><li data-v-4c27e764><a href="#常见的图片格式及使用场景" class="header-h2" data-v-4c27e764>常见的图片格式及使用场景</a></li></ul></li><li class="header" data-v-4c27e764><!----><ul data-v-4c27e764><li data-v-4c27e764><a href="#对-csssprites-的理解" class="header-h2" data-v-4c27e764>对 CSSSprites 的理解</a></li></ul></li><li class="header" data-v-4c27e764><!----><ul data-v-4c27e764><li data-v-4c27e764><a href="#margin-和-padding-的使用场景" class="header-h2" data-v-4c27e764>margin 和 padding 的使用场景</a></li></ul></li><li class="header" data-v-4c27e764><!----><ul data-v-4c27e764><li data-v-4c27e764><a href="#css-优化和提高性能的方法有哪些？" class="header-h2" data-v-4c27e764>CSS 优化和提高性能的方法有哪些？</a></li></ul></li><li class="header" data-v-4c27e764><!----><ul data-v-4c27e764><li data-v-4c27e764><a href="#z-index属性在什么情况下会失效" class="header-h2" data-v-4c27e764>z-index属性在什么情况下会失效</a></li></ul></li><li class="header" data-v-4c27e764><!----><ul data-v-4c27e764><li data-v-4c27e764><a href="#px、em、rem的区别及使用场景" class="header-h2" data-v-4c27e764>px、em、rem的区别及使用场景</a></li></ul></li><li class="header" data-v-4c27e764><!----><ul data-v-4c27e764><li data-v-4c27e764><a href="#水平垂直居中的实现" class="header-h2" data-v-4c27e764>水平垂直居中的实现</a></li></ul></li><li class="header" data-v-4c27e764><!----><ul data-v-4c27e764><li data-v-4c27e764><a href="#元素的层叠顺序" class="header-h2" data-v-4c27e764>元素的层叠顺序</a></li></ul></li><li class="header" data-v-4c27e764><!----><ul data-v-4c27e764><li data-v-4c27e764><a href="#画一条0-5px的线" class="header-h2" data-v-4c27e764>画一条0.5px的线</a></li></ul></li><li class="header" data-v-4c27e764><a href="#js基础" class="header-h1" data-v-4c27e764>js基础</a><!----></li><li class="header" data-v-4c27e764><!----><ul data-v-4c27e764><li data-v-4c27e764><a href="#javascript有哪些数据类型，它们的区别？" class="header-h2" data-v-4c27e764>JavaScript有哪些数据类型，它们的区别？</a></li></ul></li><li class="header" data-v-4c27e764><!----><ul data-v-4c27e764><li data-v-4c27e764><a href="#数据类型检测的方式有哪些" class="header-h2" data-v-4c27e764>数据类型检测的方式有哪些</a></li></ul></li><li class="header" data-v-4c27e764><!----><ul data-v-4c27e764><li data-v-4c27e764><a href="#判断数组的方式有哪些" class="header-h2" data-v-4c27e764>判断数组的方式有哪些</a></li></ul></li><li class="header" data-v-4c27e764><!----><ul data-v-4c27e764><li data-v-4c27e764><a href="#null和undefined区别" class="header-h2" data-v-4c27e764>null和undefined区别</a></li></ul></li><li class="header" data-v-4c27e764><!----><ul data-v-4c27e764><li data-v-4c27e764><a href="#typeof-null-的结果是什么，为什么？" class="header-h2" data-v-4c27e764>typeof null 的结果是什么，为什么？</a></li></ul></li><li class="header" data-v-4c27e764><!----><ul data-v-4c27e764><li data-v-4c27e764><a href="#intanceof-操作符的实现原理及实现" class="header-h2" data-v-4c27e764>intanceof 操作符的实现原理及实现</a></li></ul></li><li class="header" data-v-4c27e764><!----><ul data-v-4c27e764><li data-v-4c27e764><a href="#new操作符的实现原理" class="header-h2" data-v-4c27e764>new操作符的实现原理</a></li></ul></li><li class="header" data-v-4c27e764><!----><ul data-v-4c27e764><li data-v-4c27e764><a href="#javascript有哪些内置对象" class="header-h2" data-v-4c27e764>JavaScript有哪些内置对象</a></li></ul></li><li class="header" data-v-4c27e764><!----><ul data-v-4c27e764><li data-v-4c27e764><a href="#对json的理解" class="header-h2" data-v-4c27e764>对JSON的理解</a></li></ul></li><li class="header" data-v-4c27e764><!----><ul data-v-4c27e764><li data-v-4c27e764><a href="#为什么函数的-arguments-参数是类数组而不是数组？如何遍历类数组" class="header-h2" data-v-4c27e764>为什么函数的 arguments 参数是类数组而不是数组？如何遍历类数组?</a></li></ul></li><li class="header" data-v-4c27e764><!----><ul data-v-4c27e764><li data-v-4c27e764><a href="#javascript为什么要进行变量提升，它导致了什么问题？" class="header-h2" data-v-4c27e764>JavaScript为什么要进行变量提升，它导致了什么问题？</a></li></ul></li><li class="header" data-v-4c27e764><!----><ul data-v-4c27e764><li data-v-4c27e764><a href="#for-in和for-of的区别" class="header-h2" data-v-4c27e764>for...in和for...of的区别</a></li></ul></li><li class="header" data-v-4c27e764><!----><ul data-v-4c27e764><li data-v-4c27e764><a href="#数组的遍历方法有哪些" class="header-h2" data-v-4c27e764>数组的遍历方法有哪些</a></li></ul></li><!--]--></ul></div><!--]--><!--]--><div style="position:relative;" class="content" data-v-8fcebc32><div><h1 id="前端三剑客面试题" tabindex="-1">前端三剑客面试题 <a class="header-anchor" href="#前端三剑客面试题" aria-hidden="true">#</a></h1><h2 id="html" tabindex="-1">html <a class="header-anchor" href="#html" aria-hidden="true">#</a></h2><h3 id="src和href的区别" tabindex="-1">src和href的区别 <a class="header-anchor" href="#src和href的区别" aria-hidden="true">#</a></h3><p><strong>src：</strong> 表示对资源的引用，它指向的内容会嵌入到当前标签所在的位置。src会将其指向的资源下载并应⽤到⽂档内，如请求js脚本。当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执⾏完毕，所以⼀般js脚本会放在页面底部。</p><p><strong>href：</strong> 表示超文本引用，它指向一些网络资源，建立和当前元素或本文档的链接关系。当浏览器识别到它他指向的⽂件时，就会并⾏下载资源，不会停⽌对当前⽂档的处理。 常用在a、link等标签上。</p><h3 id="对html语义化的理解" tabindex="-1">对HTML语义化的理解 <a class="header-anchor" href="#对html语义化的理解" aria-hidden="true">#</a></h3><p><strong>语义化是指根据内容的结构化（内容语义化），选择合适的标签（代码语义化）</strong>。通俗来讲就是用正确的标签做正确的事情。</p><ul><li>对机器友好，带有语义的文字表现力丰富，更适合搜索引擎的爬虫爬取有效信息，有利于SEO。除此之外，语义类还支持读屏软件，根据文章可以自动生成目录；</li><li>对开发者友好，使用语义类标签增强了可读性，结构更加清晰，开发者能清晰的看出网页的结构，便于团队的开发与维护。</li></ul><h3 id="doctype-⽂档类型-的作⽤" tabindex="-1">DOCTYPE(⽂档类型) 的作⽤ <a class="header-anchor" href="#doctype-⽂档类型-的作⽤" aria-hidden="true">#</a></h3><p>DOCTYPE是HTML5中一种标准通用标记语言的文档类型声明，它的目的是<strong>告诉浏览器（解析器）应该以什么样（html或xhtml）的文档类型定义来解析文档</strong>，不同的渲染模式会影响浏览器对 CSS 代码甚⾄ JavaScript 脚本的解析。它必须声明在HTML⽂档的第⼀⾏。</p><p>浏览器渲染页面的两种模式（可通过document.compatMode获取，比如，语雀官网的文档类型是<strong>CSS1Compat</strong>）：</p><ul><li><strong>CSS1Compat：标准模式（Strick mode）</strong>，默认模式，浏览器使用W3C的标准解析渲染页面。在标准模式中，浏览器以其支持的最高标准呈现页面。</li><li><strong>BackCompat：怪异模式(混杂模式)(Quick mode)</strong>，浏览器使用自己的怪异模式解析渲染页面。在怪异模式中，页面以一种比较宽松的向后兼容的方式显示。</li></ul><h3 id="常⽤的meta标签有哪些" tabindex="-1">常⽤的meta标签有哪些 <a class="header-anchor" href="#常⽤的meta标签有哪些" aria-hidden="true">#</a></h3><p><code>meta</code> 标签由 <code>name</code> 和 <code>content</code> 属性定义，<strong>用来描述网页文档的属性</strong>，比如网页的作者，网页描述，关键词等，除了HTTP标准固定了一些<code>name</code>作为大家使用的共识，开发者还可以自定义name。</p><p>常用的meta标签：</p><p>（1）<code>charset</code>，用来描述HTML文档的编码类型：</p><div class="language-html"><pre><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>UTF-8<span class="token punctuation">&quot;</span></span> <span class="token punctuation">&gt;</span></span>
</code></pre></div><p>（2） <code>keywords</code>，页面关键词：</p><div class="language-html"><pre><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>keywords<span class="token punctuation">&quot;</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>关键词<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
</code></pre></div><p>（3）<code>description</code>，页面描述：</p><div class="language-html"><pre><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>description<span class="token punctuation">&quot;</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>页面描述内容<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
</code></pre></div><p>（4）<code>refresh</code>，页面重定向和刷新：</p><div class="language-html"><pre><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>refresh<span class="token punctuation">&quot;</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>0;url=<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
</code></pre></div><p>（5）<code>viewport</code>，适配移动端，可以控制视口的大小和比例：</p><div class="language-html"><pre><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>viewport<span class="token punctuation">&quot;</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>width=device-width, initial-scale=1, maximum-scale=1<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>（6）搜索引擎索引方式：</p><div class="language-html"><pre><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>robots<span class="token punctuation">&quot;</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>index,follow<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
</code></pre></div><h3 id="title与h1的区别、b与strong的区别、i与em的区别？" tabindex="-1">title与h1的区别、b与strong的区别、i与em的区别？ <a class="header-anchor" href="#title与h1的区别、b与strong的区别、i与em的区别？" aria-hidden="true">#</a></h3><ul><li>strong标签有语义，是起到加重语气的效果，而b标签是没有的，b标签只是一个简单加粗标签。b标签之间的字符都设为粗体，strong标签加强字符的语气都是通过粗体来实现的，而搜索引擎更侧重strong标签。</li><li>title属性没有明确意义只表示是个标题，H1则表示层次明确的标题，对页面信息的抓取有很大的影响</li><li><strong>i内容展示为斜体，em表示强调的文本</strong></li></ul><h3 id="label-的作用是什么？如何使用？" tabindex="-1">label 的作用是什么？如何使用？ <a class="header-anchor" href="#label-的作用是什么？如何使用？" aria-hidden="true">#</a></h3><p>label标签来定义表单控件的关系：当用户选择label标签时，浏览器会自动将焦点转到和label标签相关的表单控件上。</p><h3 id="浏览器乱码的原因是什么？如何解决？" tabindex="-1">浏览器乱码的原因是什么？如何解决？ <a class="header-anchor" href="#浏览器乱码的原因是什么？如何解决？" aria-hidden="true">#</a></h3><p><strong>产生乱码的原因：</strong></p><ul><li>网页源代码是<code>gbk</code>的编码，而内容中的中文字是<code>utf-8</code>编码的，这样浏览器打开即会出现<code>html</code>乱码，反之也会出现乱码；</li><li><code>html</code>网页编码是<code>gbk</code>，而程序从数据库中调出呈现是<code>utf-8</code>编码的内容也会造成编码乱码；</li><li>浏览器不能自动检测网页编码，造成网页乱码。</li></ul><p><strong>解决办法：</strong></p><ul><li>使用软件编辑HTML网页内容；</li><li>如果网页设置编码是<code>gbk</code>，而数据库储存数据编码格式是<code>UTF-8</code>，此时需要程序查询数据库数据显示数据前进程序转码；</li><li>如果浏览器浏览时候出现网页乱码，在浏览器中找到转换编码的菜单进行转换。</li></ul><h3 id="渐进增强和优雅降级之间的区别" tabindex="-1">渐进增强和优雅降级之间的区别 <a class="header-anchor" href="#渐进增强和优雅降级之间的区别" aria-hidden="true">#</a></h3><p><strong>（1）渐进增强（progressive enhancement）</strong>：主要是针对低版本的浏览器进行页面重构，保证基本的功能情况下，再针对高级浏览器进行效果、交互等方面的改进和追加功能，以达到更好的用户体验。 <strong>（2）优雅降级 graceful degradation</strong>： 一开始就构建完整的功能，然后再针对低版本的浏览器进行兼容。</p><p><strong>两者区别：</strong></p><ul><li>优雅降级是从复杂的现状开始的，并试图减少用户体验的供给；而渐进增强是从一个非常基础的，能够起作用的版本开始的，并在此基础上不断扩充，以适应未来环境的需要；</li><li>降级（功能衰竭）意味着往回看，而渐进增强则意味着往前看，同时保证其根基处于安全地带。</li></ul><p>“优雅降级”观点认为应该针对那些最高级、最完善的浏览器来设计网站。而将那些被认为“过时”或有功能缺失的浏览器下的测试工作安排在开发周期的最后阶段，并把测试对象限定为主流浏览器（如 IE、Mozilla 等）的前一个版本。 在这种设计范例下，旧版的浏览器被认为仅能提供“简陋却无妨 (poor, but passable)” 的浏览体验。可以做一些小的调整来适应某个特定的浏览器。但由于它们并非我们所关注的焦点，因此除了修复较大的错误之外，其它的差异将被直接忽略。</p><p>“渐进增强”观点则认为应关注于内容本身。内容是建立网站的诱因，有的网站展示它，有的则收集它，有的寻求，有的操作，还有的网站甚至会包含以上的种种，但相同点是它们全都涉及到内容。这使得“渐进增强”成为一种更为合理的设计范例。这也是它立即被 Yahoo 所采纳并用以构建其“分级式浏览器支持 (Graded Browser Support)”策略的原因所在。</p><h2 id="css" tabindex="-1">css <a class="header-anchor" href="#css" aria-hidden="true">#</a></h2><h3 id="隐藏元素的方法有哪些" tabindex="-1">隐藏元素的方法有哪些 <a class="header-anchor" href="#隐藏元素的方法有哪些" aria-hidden="true">#</a></h3><ul><li><strong>display: none</strong>：渲染树不会包含该渲染对象，因此该元素不会在页面中占据位置，也不会响应绑定的监听事件。</li><li><strong>visibility: hidden</strong>：元素在页面中仍占据空间，但是不会响应绑定的监听事件。</li><li><strong>opacity: 0</strong>：将元素的透明度设置为 0，以此来实现元素的隐藏。元素在页面中仍然占据空间，并且能够响应元素绑定的监听事件。</li><li><strong>position: absolute</strong>：通过使用绝对定位将元素移除可视区域内，以此来实现元素的隐藏。</li><li><strong>z-index: 负值</strong>：来使其他元素遮盖住该元素，以此来实现隐藏。</li><li><strong>clip/clip-path</strong> ：使用元素裁剪的方法来实现元素的隐藏，这种方法下，元素仍在页面中占据位置，但是不会响应绑定的监听事件。</li><li><strong>transform: scale(0,0)</strong>：将元素缩放为 0，来实现元素的隐藏。这种方法下，元素仍在页面中占据位置，但是不会响应绑定的监听事件。</li></ul><h3 id="transition和animation的区别" tabindex="-1">transition和animation的区别 <a class="header-anchor" href="#transition和animation的区别" aria-hidden="true">#</a></h3><ul><li><strong>transition是过度属性</strong>，强调过度，它的实现需要触发一个事件（比如鼠标移动上去，焦点，点击等）才执行动画。它类似于flash的补间动画，设置一个开始关键帧，一个结束关键帧。</li><li><strong>animation是动画属性</strong>，它的实现不需要触发事件，设定好时间之后可以自己执行，且可以循环一个动画。它也类似于flash的补间动画，但是它可以设置多个关键帧（用@keyframe定义）完成动画。</li></ul><h3 id="link和-import的区别" tabindex="-1">link和@import的区别 <a class="header-anchor" href="#link和-import的区别" aria-hidden="true">#</a></h3><p>两者都是外部引用CSS的方式，它们的区别如下：</p><ul><li>link是XHTML标签，除了加载CSS外，还可以定义RSS等其他事务；@import属于CSS范畴，只能加载CSS。</li><li>link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载。</li><li>link是XHTML标签，无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持。</li><li>link支持使用Javascript控制DOM去改变样式；而@import不支持。</li></ul><h3 id="display-none与visibility-hidden的区别" tabindex="-1">display:none与visibility:hidden的区别 <a class="header-anchor" href="#display-none与visibility-hidden的区别" aria-hidden="true">#</a></h3><p>这两个属性都是让元素隐藏，不可见。<strong>两者区别如下：</strong></p><p>（1）<strong>在渲染树中</strong></p><ul><li><code>display:none</code>会让元素完全从渲染树中消失，渲染时不会占据任何空间；</li><li><code>visibility:hidden</code>不会让元素从渲染树中消失，渲染的元素还会占据相应的空间，只是内容不可见。</li></ul><p>（2）<strong>是否是继承属性</strong></p><ul><li><code>display:none</code>是非继承属性，子孙节点会随着父节点从渲染树消失，通过修改子孙节点的属性也无法显示；</li><li><code>visibility:hidden</code>是继承属性，子孙节点消失是由于继承了<code>hidden</code>，通过设置<code>visibility:visible</code>可以让子孙节点显示；</li></ul><p>（3）修改常规文档流中元素的 <code>display</code> 通常会造成文档的重排，但是修改<code>visibility</code>属性只会造成本元素的重绘；</p><p>（4）如果使用读屏器，设置为<code>display:none</code>的内容不会被读取，设置为<code>visibility:hidden</code>的内容会被读取。</p><h3 id="伪元素和伪类的区别和作用？" tabindex="-1"><strong>伪元素和伪类的区别和作用？</strong> <a class="header-anchor" href="#伪元素和伪类的区别和作用？" aria-hidden="true">#</a></h3><ul><li>伪元素：在内容元素的前后插入额外的元素或样式，但是这些元素实际上并不在文档中生成。它们只在外部显示可见，但不会在文档的源代码中找到它们，因此，称为“伪”元素。例如：</li></ul><div class="language-css"><pre><code><span class="token selector">p::before</span> <span class="token punctuation">{</span><span class="token property">content</span><span class="token punctuation">:</span><span class="token string">&quot;第一章：&quot;</span><span class="token punctuation">;</span><span class="token punctuation">}</span>
<span class="token selector">p::after</span> <span class="token punctuation">{</span><span class="token property">content</span><span class="token punctuation">:</span><span class="token string">&quot;Hot!&quot;</span><span class="token punctuation">;</span><span class="token punctuation">}</span>
<span class="token selector">p::first-line</span> <span class="token punctuation">{</span><span class="token property">background</span><span class="token punctuation">:</span>red<span class="token punctuation">;</span><span class="token punctuation">}</span>
<span class="token selector">p::first-letter</span> <span class="token punctuation">{</span><span class="token property">font-size</span><span class="token punctuation">:</span>30px<span class="token punctuation">;</span><span class="token punctuation">}</span>
</code></pre></div><ul><li>伪类：将特殊的效果添加到特定选择器上。它是已有元素上添加类别的，不会产生新的元素。例如：</li></ul><div class="language-css"><pre><code><span class="token selector">a:hover</span> <span class="token punctuation">{</span><span class="token property">color</span><span class="token punctuation">:</span> #FF00FF<span class="token punctuation">}</span>
<span class="token selector">p:first-child</span> <span class="token punctuation">{</span><span class="token property">color</span><span class="token punctuation">:</span> red<span class="token punctuation">}</span>
</code></pre></div><p><strong>总结：</strong> 伪类是通过在元素选择器上加⼊伪类改变元素状态，⽽伪元素通过对元素的操作进⾏对元素的改变。</p><h3 id="为什么有时候⽤translate来改变位置⽽不是定位？" tabindex="-1">为什么有时候⽤<strong>translate</strong>来改变位置⽽不是定位？ <a class="header-anchor" href="#为什么有时候⽤translate来改变位置⽽不是定位？" aria-hidden="true">#</a></h3><p>translate 是 transform 属性的⼀个值。改变transform或opacity不会触发浏览器重新布局（reflow）或重绘（repaint），只会触发复合（compositions）。⽽改变绝对定位会触发重新布局，进⽽触发重绘和复合。transform使浏览器为元素创建⼀个 GPU 图层，但改变绝对定位会使⽤到 CPU。 因此translate()更⾼效，可以缩短平滑动画的绘制时间。 ⽽translate改变位置时，元素依然会占据其原始空间，绝对定位就不会发⽣这种情况。</p><h3 id="常见的图片格式及使用场景" tabindex="-1">常见的图片格式及使用场景 <a class="header-anchor" href="#常见的图片格式及使用场景" aria-hidden="true">#</a></h3><p>（1）<strong>BMP</strong>，是无损的、既支持索引色也支持直接色的点阵图。这种图片格式几乎没有对数据进行压缩，所以BMP格式的图片通常是较大的文件。</p><p>（2）<strong>GIF</strong>是无损的、采用索引色的点阵图。采用LZW压缩算法进行编码。文件小，是GIF格式的优点，同时，GIF格式还具有支持动画以及透明的优点。但是GIF格式仅支持8bit的索引色，所以GIF格式适用于对色彩要求不高同时需要文件体积较小的场景。</p><p>（3）<strong>JPEG</strong>是有损的、采用直接色的点阵图。JPEG的图片的优点是采用了直接色，得益于更丰富的色彩，JPEG非常适合用来存储照片，与GIF相比，JPEG不适合用来存储企业Logo、线框类的图。因为有损压缩会导致图片模糊，而直接色的选用，又会导致图片文件较GIF更大。</p><p>（4）<strong>PNG-8</strong>是无损的、使用索引色的点阵图。PNG是一种比较新的图片格式，PNG-8是非常好的GIF格式替代者，在可能的情况下，应该尽可能的使用PNG-8而不是GIF，因为在相同的图片效果下，PNG-8具有更小的文件体积。除此之外，PNG-8还支持透明度的调节，而GIF并不支持。除非需要动画的支持，否则没有理由使用GIF而不是PNG-8。</p><p>（5）<strong>PNG-24</strong>是无损的、使用直接色的点阵图。PNG-24的优点在于它压缩了图片的数据，使得同样效果的图片，PNG-24格式的文件大小要比BMP小得多。当然，PNG24的图片还是要比JPEG、GIF、PNG-8大得多。</p><p>（6）<strong>SVG</strong>是无损的矢量图。SVG是矢量图意味着SVG图片由直线和曲线以及绘制它们的方法组成。当放大SVG图片时，看到的还是线和曲线，而不会出现像素点。SVG图片在放大时，不会失真，所以它适合用来绘制Logo、Icon等。</p><p>（7）<strong>WebP</strong>是谷歌开发的一种新图片格式，WebP是同时支持有损和无损压缩的、使用直接色的点阵图。从名字就可以看出来它是为Web而生的，什么叫为Web而生呢？就是说相同质量的图片，WebP具有更小的文件体积。现在网站上充满了大量的图片，如果能够降低每一个图片的文件大小，那么将大大减少浏览器和服务器之间的数据传输量，进而降低访问延迟，提升访问体验。目前只有Chrome浏览器和Opera浏览器支持WebP格式，兼容性不太好。</p><ul><li>在无损压缩的情况下，相同质量的WebP图片，文件大小要比PNG小26%；</li><li>在有损压缩的情况下，具有相同图片精度的WebP图片，文件大小要比JPEG小25%~34%；</li><li>WebP图片格式支持图片透明度，一个无损压缩的WebP图片，如果要支持透明度只需要22%的格外文件大小。</li></ul><h3 id="对-csssprites-的理解" tabindex="-1">对 CSSSprites 的理解 <a class="header-anchor" href="#对-csssprites-的理解" aria-hidden="true">#</a></h3><p>CSSSprites（精灵图），将一个页面涉及到的所有图片都包含到一张大图中去，然后利用CSS的 background-image，background-repeat，background-position属性的组合进行背景定位。</p><p><strong>优点：</strong></p><ul><li>利用<code>CSS Sprites</code>能很好地减少网页的http请求，从而大大提高了页面的性能，这是<code>CSS Sprites</code>最大的优点；</li><li><code>CSS Sprites</code>能减少图片的字节，把3张图片合并成1张图片的字节总是小于这3张图片的字节总和。</li></ul><p><strong>缺点：</strong></p><ul><li>在图片合并时，要把多张图片有序的、合理的合并成一张图片，还要留好足够的空间，防止板块内出现不必要的背景。在宽屏及高分辨率下的自适应页面，如果背景不够宽，很容易出现背景断裂；</li><li><code>CSSSprites</code>在开发的时候相对来说有点麻烦，需要借助<code>photoshop</code>或其他工具来对每个背景单元测量其准确的位置。</li><li>维护方面：<code>CSS Sprites</code>在维护的时候比较麻烦，页面背景有少许改动时，就要改这张合并的图片，无需改的地方尽量不要动，这样避免改动更多的<code>CSS</code>，如果在原来的地方放不下，又只能（最好）往下加图片，这样图片的字节就增加了，还要改动<code>CSS</code>。</li></ul><h3 id="margin-和-padding-的使用场景" tabindex="-1"><strong>margin 和 padding 的使用场景</strong> <a class="header-anchor" href="#margin-和-padding-的使用场景" aria-hidden="true">#</a></h3><ul><li>需要在border外侧添加空白，且空白处不需要背景（色）时，使用 margin；</li><li>需要在border内测添加空白，且空白处需要背景（色）时，使用 padding。</li></ul><h3 id="css-优化和提高性能的方法有哪些？" tabindex="-1">CSS 优化和提高性能的方法有哪些？ <a class="header-anchor" href="#css-优化和提高性能的方法有哪些？" aria-hidden="true">#</a></h3><p><strong>加载性能：</strong></p><p>（1）css压缩：将写好的css进行打包压缩，可以减小文件体积。</p><p>（2）css单一样式：当需要下边距和左边距的时候，很多时候会选择使用 margin:top 0 bottom 0；但margin-bottom:bottom;margin-left:left;执行效率会更高。</p><p>（3）减少使用@import，建议使用link，因为后者在页面加载时一起加载，前者是等待页面加载完成之后再进行加载。</p><p><strong>选择器性能：</strong></p><p>（1）关键选择器（key selector）。选择器的最后面的部分为关键选择器（即用来匹配目标元素的部分）。CSS选择符是从右到左进行匹配的。当使用后代选择器的时候，浏览器会遍历所有子元素来确定是否是指定的元素等等；</p><p>（2）如果规则拥有ID选择器作为其关键选择器，则不要为规则增加标签。过滤掉无关的规则（这样样式系统就不会浪费时间去匹配它们了）。</p><p>（3）避免使用通配规则，如*{}计算次数惊人，只对需要用到的元素进行选择。</p><p>（4）尽量少的去对标签进行选择，而是用class。</p><p>（5）尽量少的去使用后代选择器，降低选择器的权重值。后代选择器的开销是最高的，尽量将选择器的深度降到最低，最高不要超过三层，更多的使用类来关联每一个标签元素。</p><p>（6）了解哪些属性是可以通过继承而来的，然后避免对这些属性重复指定规则。</p><p><strong>渲染性能：</strong></p><p>（1）慎重使用高性能属性：浮动、定位。</p><p>（2）尽量减少页面重排、重绘。</p><p>（3）去除空规则：｛｝。空规则的产生原因一般来说是为了预留样式。去除这些空规则无疑能减少css文档体积。</p><p>（4）属性值为0时，不加单位。</p><p>（5）属性值为浮动小数0.**，可以省略小数点之前的0。</p><p>（6）标准化各种浏览器前缀：带浏览器前缀的在前。标准属性在后。</p><p>（7）不使用@import前缀，它会影响css的加载速度。</p><p>（8）选择器优化嵌套，尽量避免层级过深。</p><p>（9）css雪碧图，同一页面相近部分的小图标，方便使用，减少页面的请求次数，但是同时图片本身会变大，使用时，优劣考虑清楚，再使用。</p><p>（10）正确使用display的属性，由于display的作用，某些样式组合会无效，徒增样式体积的同时也影响解析性能。</p><p>（11）不滥用web字体。对于中文网站来说WebFonts可能很陌生，国外却很流行。web fonts通常体积庞大，而且一些浏览器在下载web fonts时会阻塞页面渲染损伤性能。</p><p><strong>可维护性、健壮性：</strong></p><p>（1）将具有相同属性的样式抽离出来，整合并通过class在页面中进行使用，提高css的可维护性。</p><p>（2）样式与内容分离：将css代码定义到外部css中。</p><h3 id="z-index属性在什么情况下会失效" tabindex="-1">z-index属性在什么情况下会失效 <a class="header-anchor" href="#z-index属性在什么情况下会失效" aria-hidden="true">#</a></h3><p>通常 z-index 的使用是在有两个重叠的标签，在一定的情况下控制其中一个在另一个的上方或者下方出现。z-index值越大就越是在上层。z-index元素的position属性需要是relative，absolute或是fixed。</p><p>z-index属性在下列情况下会失效：</p><ul><li>父元素position为relative时，子元素的z-index失效。解决：父元素position改为absolute或static；</li><li>元素没有设置position属性为非static属性。解决：设置该元素的position属性为relative，absolute或是fixed中的一种；</li><li>元素在设置z-index的同时还设置了float浮动。解决：float去除，改为display：inline-block；</li></ul><h3 id="px、em、rem的区别及使用场景" tabindex="-1">px、em、rem的区别及使用场景 <a class="header-anchor" href="#px、em、rem的区别及使用场景" aria-hidden="true">#</a></h3><p><strong>三者的区别：</strong></p><ul><li>px是固定的像素，一旦设置了就无法因为适应页面大小而改变。</li><li>em和rem相对于px更具有灵活性，他们是相对长度单位，其长度不是固定的，更适用于响应式布局。</li><li>em是相对于其父元素来设置字体大小，这样就会存在一个问题，进行任何元素设置，都有可能需要知道他父元素的大小。而rem是相对于根元素，这样就意味着，只需要在根元素确定一个参考值。</li></ul><p><strong>使用场景：</strong></p><ul><li>对于只需要适配少部分移动设备，且分辨率对页面影响不大的，使用px即可 。</li><li>对于需要适配各种移动设备，使用rem，例如需要适配iPhone和iPad等分辨率差别比较挺大的设备。</li></ul><h3 id="水平垂直居中的实现" tabindex="-1">水平垂直居中的实现 <a class="header-anchor" href="#水平垂直居中的实现" aria-hidden="true">#</a></h3><ul><li>利用绝对定位，先将元素的左上角通过top:50%和left:50%定位到页面的中心，然后再通过translate来调整元素的中心点到页面的中心。该方法需要<strong>考虑浏览器兼容问题。</strong></li></ul><div class="language-css"><pre><code><span class="token selector">.parent</span> <span class="token punctuation">{</span>    
    <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span>
<span class="token punctuation">}</span> 
<span class="token selector">.child</span> <span class="token punctuation">{</span>    
    <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>    
    <span class="token property">left</span><span class="token punctuation">:</span> 50%<span class="token punctuation">;</span>    
    <span class="token property">top</span><span class="token punctuation">:</span> 50%<span class="token punctuation">;</span>    
    <span class="token property">transform</span><span class="token punctuation">:</span> <span class="token function">translate</span><span class="token punctuation">(</span>-50%<span class="token punctuation">,</span>-50%<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>利用绝对定位，设置四个方向的值都为0，并将margin设置为auto，由于宽高固定，因此对应方向实现平分，可以实现水平和垂直方向上的居中。该方法适用于<strong>盒子有宽高</strong>的情况：</li></ul><div class="language-css"><pre><code><span class="token selector">.parent</span> <span class="token punctuation">{</span>
    <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
 
<span class="token selector">.child</span> <span class="token punctuation">{</span>
    <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>
    <span class="token property">top</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>
    <span class="token property">bottom</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>
    <span class="token property">left</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>
    <span class="token property">right</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>
    <span class="token property">margin</span><span class="token punctuation">:</span> auto<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>利用绝对定位，先将元素的左上角通过top:50%和left:50%定位到页面的中心，然后再通过margin负值来调整元素的中心点到页面的中心。该方法适用于<strong>盒子宽高已知</strong>的情况</li></ul><div class="language-css"><pre><code><span class="token selector">.parent</span> <span class="token punctuation">{</span>
    <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
 
<span class="token selector">.child</span> <span class="token punctuation">{</span>
    <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>
    <span class="token property">top</span><span class="token punctuation">:</span> 50%<span class="token punctuation">;</span>
    <span class="token property">left</span><span class="token punctuation">:</span> 50%<span class="token punctuation">;</span>
    <span class="token property">margin-top</span><span class="token punctuation">:</span> -50px<span class="token punctuation">;</span>     <span class="token comment">/* 自身 height 的一半 */</span>
    <span class="token property">margin-left</span><span class="token punctuation">:</span> -50px<span class="token punctuation">;</span>    <span class="token comment">/* 自身 width 的一半 */</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>使用flex布局，通过align-items:center和justify-content:center设置容器的垂直和水平方向上为居中对齐，然后它的子元素也可以实现垂直和水平的居中。该方法要<strong>考虑兼容的问题</strong>，该方法在移动端用的较多：</li></ul><div class="language-css"><pre><code><span class="token selector">.parent</span> <span class="token punctuation">{</span>
    <span class="token property">display</span><span class="token punctuation">:</span> flex<span class="token punctuation">;</span>
    <span class="token property">justify-content</span><span class="token punctuation">:</span>center<span class="token punctuation">;</span>
    <span class="token property">align-items</span><span class="token punctuation">:</span>center<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="元素的层叠顺序" tabindex="-1">元素的层叠顺序 <a class="header-anchor" href="#元素的层叠顺序" aria-hidden="true">#</a></h3><p>层叠顺序，英文称作 stacking order，表示元素发生层叠时有着特定的垂直显示顺序。下面是盒模型的层叠规则： <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fbc59ae1adb5454c8c7f60582df10ff9~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>对于上图，由上到下分别是：</p><p>（1）背景和边框：建立当前层叠上下文元素的背景和边框。</p><p>（2）负的z-index：当前层叠上下文中，z-index属性值为负的元素。</p><p>（3）块级盒：文档流内非行内级非定位后代元素。</p><p>（4）浮动盒：非定位浮动元素。</p><p>（5）行内盒：文档流内行内级非定位后代元素。</p><p>（6）z-index:0：层叠级数为0的定位元素。</p><p>（7）正z-index：z-index属性值为正的定位元素。</p><p><strong>注意:</strong> 当定位元素z-index:auto，生成盒在当前层叠上下文中的层级为 0，不会建立新的层叠上下文，除非是根元素。</p><h3 id="画一条0-5px的线" tabindex="-1">画一条0.5px的线 <a class="header-anchor" href="#画一条0-5px的线" aria-hidden="true">#</a></h3><ul><li><strong>采用transform: scale()的方式</strong>，该方法用来定义元素的2D 缩放转换：</li></ul><div class="language-css"><pre><code><span class="token property">transform</span><span class="token punctuation">:</span> <span class="token function">scale</span><span class="token punctuation">(</span>0.5<span class="token punctuation">,</span>0.5<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><ul><li><strong>采用meta viewport的方式</strong></li></ul><div class="language-css"><pre><code>&lt;meta name=<span class="token string">&quot;viewport&quot;</span> content=<span class="token string">&quot;width=device-width, initial-scale=0.5, minimum-scale=0.5, maximum-scale=0.5&quot;</span>/&gt;
</code></pre></div><p>这样就能缩放到原来的0.5倍，如果是1px那么就会变成0.5px。viewport只针对于移动端，只在移动端上才能看到效果</p><h2 id="js基础" tabindex="-1">js基础 <a class="header-anchor" href="#js基础" aria-hidden="true">#</a></h2><h3 id="javascript有哪些数据类型，它们的区别？" tabindex="-1">JavaScript有哪些数据类型，它们的区别？ <a class="header-anchor" href="#javascript有哪些数据类型，它们的区别？" aria-hidden="true">#</a></h3><p>JavaScript共有八种数据类型，分别是 Undefined、Null、Boolean、Number、String、Object、Symbol、BigInt。</p><p>其中 Symbol 和 BigInt 是ES6 中新增的数据类型：</p><ul><li>Symbol 代表创建后独一无二且不可变的数据类型，它主要是为了解决可能出现的全局变量冲突的问题。</li><li>BigInt 是一种数字类型的数据，它可以表示任意精度格式的整数，使用 BigInt 可以安全地存储和操作大整数，即使这个数已经超出了 Number 能够表示的安全整数范围。</li></ul><p>这些数据可以分为原始数据类型和引用数据类型：</p><ul><li>栈：原始数据类型（Undefined、Null、Boolean、Number、String）</li><li>堆：引用数据类型（对象、数组和函数）</li></ul><p>两种类型的区别在于<strong>存储位置的不同：</strong></p><ul><li>原始数据类型直接存储在栈（stack）中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；</li><li>引用数据类型存储在堆（heap）中的对象，占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。</li></ul><p>堆和栈的概念存在于数据结构和操作系统内存中，在数据结构中：</p><ul><li>在数据结构中，栈中数据的存取方式为先进后出。</li><li>堆是一个优先队列，是按优先级来进行排序的，优先级可以按照大小来规定。</li></ul><p>在操作系统中，内存被分为栈区和堆区：</p><ul><li>栈区内存由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。</li><li>堆区内存一般由开发着分配释放，若开发者不释放，程序结束时可能由垃圾回收机制回收。</li></ul><h3 id="数据类型检测的方式有哪些" tabindex="-1">数据类型检测的方式有哪些 <a class="header-anchor" href="#数据类型检测的方式有哪些" aria-hidden="true">#</a></h3><p><strong>（1）typeof</strong></p><div class="language-javascript"><pre><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token comment">// number</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// boolean</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token string">&#39;str&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment">// string</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment">// object    </span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// function</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment">// object</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// undefined</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// object</span>
</code></pre></div><p>其中数组、对象、null都会被判断为object，其他判断都正确。</p><p><strong>（2）instanceof</strong></p><p><code>instanceof</code>可以正确判断对象的类型，<strong>其内部运行机制是判断在其原型链中能否找到该类型的原型</strong>。</p><div class="language-javascript"><pre><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token keyword">instanceof</span> <span class="token class-name">Number</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">// false</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token boolean">true</span> <span class="token keyword">instanceof</span> <span class="token class-name">Boolean</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// false </span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;str&#39;</span> <span class="token keyword">instanceof</span> <span class="token class-name">String</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// false </span>
 
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token keyword">instanceof</span> <span class="token class-name">Array</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token keyword">instanceof</span> <span class="token class-name">Function</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token keyword">instanceof</span> <span class="token class-name">Object</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token comment">// true</span>
</code></pre></div><p>可以看到，<code>instanceof</code><strong>只能正确判断引用数据类型</strong>，而不能判断基本数据类型。<code>instanceof</code> 运算符可以用来测试一个对象在其原型链中是否存在一个构造函数的 <code>prototype</code> 属性。</p><p><strong>（3） constructor</strong></p><div class="language-javascript"><pre><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span>constructor <span class="token operator">===</span> Number<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">.</span>constructor <span class="token operator">===</span> Boolean<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">&#39;str&#39;</span><span class="token punctuation">)</span><span class="token punctuation">.</span>constructor <span class="token operator">===</span> String<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span>constructor <span class="token operator">===</span> Array<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span>constructor <span class="token operator">===</span> Function<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span>constructor <span class="token operator">===</span> Object<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
</code></pre></div><p><code>constructor</code>有两个作用，一是判断数据的类型，二是对象实例通过 <code>constrcutor</code> 对象访问它的构造函数。需要注意，如果创建一个对象来改变它的原型，<code>constructor</code>就不能用来判断数据类型了：</p><div class="language-javascript"><pre><code><span class="token keyword">function</span> <span class="token function">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
 
<span class="token class-name">Fn</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
<span class="token keyword">var</span> f <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>f<span class="token punctuation">.</span>constructor<span class="token operator">===</span>Fn<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// false</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>f<span class="token punctuation">.</span>constructor<span class="token operator">===</span>Array<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
</code></pre></div><p><strong>（4）Object.prototype.toString.call()</strong></p><p><code>Object.prototype.toString.call()</code> 使用 Object 对象的原型方法 toString 来判断数据类型：</p><div class="language-javascript"><pre><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>toString<span class="token punctuation">;</span>
 
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">a</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">a</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">a</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">&#39;str&#39;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">a</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">a</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">a</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">a</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">undefined</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">a</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>同样是检测对象obj调用toString方法，obj.toString()的结果和Object.prototype.toString.call(obj)的结果不一样，这是为什么？</p><p>这是因为toString是Object的原型方法，而Array、function等<strong>类型作为Object的实例，都重写了toString方法</strong>。不同的对象类型调用toString方法时，根据原型链的知识，调用的是对应的重写之后的toString方法（function类型返回内容为函数体的字符串，Array类型返回元素组成的字符串…），而不会去调用Object上原型toString方法（返回对象的具体类型），所以采用obj.toString()不能得到其对象类型，只能将obj转换为字符串类型；因此，在想要得到对象的具体类型时，应该调用Object原型上的toString方法。</p><h3 id="判断数组的方式有哪些" tabindex="-1">判断数组的方式有哪些 <a class="header-anchor" href="#判断数组的方式有哪些" aria-hidden="true">#</a></h3><ul><li>通过Object.prototype.toString.call()做判断</li></ul><div class="language-javascript"><pre><code><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">&#39;Array&#39;</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>通过原型链做判断</li></ul><div class="language-javascript"><pre><code>obj<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>
</code></pre></div><ul><li>通过ES6的Array.isArray()做判断</li></ul><div class="language-javascript"><pre><code>Array<span class="token punctuation">.</span><span class="token function">isArrray</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>通过instanceof做判断</li></ul><div class="language-javascript"><pre><code>obj <span class="token keyword">instanceof</span> <span class="token class-name">Array</span>
</code></pre></div><ul><li>通过Array.prototype.isPrototypeOf</li></ul><div class="language-javascript"><pre><code><span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">isPrototypeOf</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>
</code></pre></div><h3 id="null和undefined区别" tabindex="-1">null和undefined区别 <a class="header-anchor" href="#null和undefined区别" aria-hidden="true">#</a></h3><p>首先 Undefined 和 Null 都是基本数据类型，这两个基本数据类型分别都只有一个值，就是 undefined 和 null。</p><p>undefined 代表的含义是<strong>未定义</strong>，null 代表的含义是<strong>空对象</strong>。一般变量声明了但还没有定义的时候会返回 undefined，null主要用于赋值给一些可能会返回对象的变量，作为初始化。</p><p>undefined 在 JavaScript 中不是一个保留字，这意味着可以使用 undefined 来作为一个变量名，但是这样的做法是非常危险的，它会影响对 undefined 值的判断。我们可以通过一些方法获得安全的 undefined 值，比如说 void 0。</p><p>当对这两种类型使用 typeof 进行判断时，Null 类型化会返回 “object”，这是一个历史遗留的问题。当使用双等号对两种类型的值进行比较时会返回 true，使用三个等号时会返回 false。</p><h3 id="typeof-null-的结果是什么，为什么？" tabindex="-1">typeof null 的结果是什么，为什么？ <a class="header-anchor" href="#typeof-null-的结果是什么，为什么？" aria-hidden="true">#</a></h3><p>typeof null 的结果是Object。</p><p>在 JavaScript 第一个版本中，所有值都存储在 32 位的单元中，每个单元包含一个小的 <strong>类型标签(1-3 bits)</strong> 以及当前要存储值的真实数据。类型标签存储在每个单元的低位中，共有五种数据类型：</p><div class="language-javascript"><pre><code><span class="token number">000</span><span class="token operator">:</span> object   <span class="token operator">-</span> 当前存储的数据指向一个对象。
  <span class="token number">1</span><span class="token operator">:</span> int      <span class="token operator">-</span> 当前存储的数据是一个 <span class="token number">31</span> 位的有符号整数。
<span class="token number">010</span><span class="token operator">:</span> double   <span class="token operator">-</span> 当前存储的数据指向一个双精度的浮点数。
<span class="token number">100</span><span class="token operator">:</span> string   <span class="token operator">-</span> 当前存储的数据指向一个字符串。
<span class="token number">110</span><span class="token operator">:</span> boolean  <span class="token operator">-</span> 当前存储的数据是布尔值。
</code></pre></div><p>如果最低位是 1，则类型标签标志位的长度只有一位；如果最低位是 0，则类型标签标志位的长度占三位，为存储其他四种数据类型提供了额外两个 bit 的长度。</p><p>有两种特殊数据类型：</p><ul><li>undefined的值是 (-2)30(一个超出整数范围的数字)；</li><li>null 的值是机器码 NULL 指针(null 指针的值全是 0)</li></ul><p>那也就是说null的类型标签也是000，和Object的类型标签一样，所以会被判定为Object。</p><h3 id="intanceof-操作符的实现原理及实现" tabindex="-1">intanceof 操作符的实现原理及实现 <a class="header-anchor" href="#intanceof-操作符的实现原理及实现" aria-hidden="true">#</a></h3><p>instanceof 运算符用于判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。</p><div class="language-javascript"><pre><code><span class="token keyword">function</span> <span class="token function">myInstanceof</span><span class="token punctuation">(</span><span class="token parameter">left<span class="token punctuation">,</span> right</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 获取对象的原型</span>
  <span class="token keyword">let</span> proto <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span>
  <span class="token comment">// 获取构造函数的 prototype 对象</span>
  <span class="token keyword">let</span> prototype <span class="token operator">=</span> right<span class="token punctuation">.</span>prototype<span class="token punctuation">;</span> 
 
  <span class="token comment">// 判断构造函数的 prototype 对象是否在对象的原型链上</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>proto<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>proto <span class="token operator">===</span> prototype<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token comment">// 如果没有找到，就继续从其原型上找，Object.getPrototypeOf方法用来获取指定对象的原型</span>
    proto <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>proto<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="new操作符的实现原理" tabindex="-1">new操作符的实现原理 <a class="header-anchor" href="#new操作符的实现原理" aria-hidden="true">#</a></h3><p><strong>new操作符的执行过程：</strong></p><p>（1）首先创建了一个新的空对象</p><p>（2）设置原型，将对象的原型设置为函数的 prototype 对象。</p><p>（3）让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）</p><p>（4）判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。</p><h3 id="javascript有哪些内置对象" tabindex="-1">JavaScript有哪些内置对象 <a class="header-anchor" href="#javascript有哪些内置对象" aria-hidden="true">#</a></h3><p>全局的对象（ global objects ）或称标准内置对象，不要和 &quot;全局对象（global object）&quot; 混淆。这里说的全局的对象是说在 全局作用域里的对象。全局作用域中的其他对象可以由用户的脚本创建或由宿主程序提供。</p><p><strong>标准内置对象的分类：</strong></p><p>（1）值属性，这些全局属性返回一个简单值，这些值没有自己的属性和方法。例如 Infinity、NaN、undefined、null 字面量</p><p>（2）函数属性，全局函数可以直接调用，不需要在调用时指定所属对象，执行结束后会将结果直接返回给调用者。例如 eval()、parseFloat()、parseInt() 等</p><p>（3）基本对象，基本对象是定义或使用其他对象的基础。基本对象包括一般对象、函数对象和错误对象。例如 Object、Function、Boolean、Symbol、Error 等</p><p>（4）数字和日期对象，用来表示数字、日期和执行数学计算的对象。例如 Number、Math、Date</p><p>（5）字符串，用来表示和操作字符串的对象。例如 String、RegExp</p><p>（6）可索引的集合对象，这些对象表示按照索引值来排序的数据集合，包括数组和类型数组，以及类数组结构的对象。例如 Array</p><p>（7）使用键的集合对象，这些集合对象在存储数据时会使用到键，支持按照插入顺序来迭代元素。 例如 Map、Set、WeakMap、WeakSet</p><p>（8）矢量集合，SIMD 矢量集合中的数据会被组织为一个数据序列。 例如 SIMD 等</p><p>（9）结构化数据，这些对象用来表示和操作结构化的缓冲区数据，或使用 JSON 编码的数据。例如 JSON 等</p><p>（10）控制抽象对象 例如 Promise、Generator 等</p><p>（11）反射。例如 Reflect、Proxy</p><p>（12）国际化，为了支持多语言处理而加入 ECMAScript 的对象。例如 Intl、Intl.Collator 等</p><p>（13）WebAssembly</p><p>（14）其他。例如 arguments</p><p><strong>总结：</strong> js 中的内置对象主要指的是在程序执行前存在全局作用域里的由 js 定义的一些全局值属性、函数和用来实例化其他对象的构造函数对象。一般经常用到的如全局变量值 NaN、undefined，全局函数如 parseInt()、parseFloat() 用来实例化对象的构造函数如 Date、Object 等，还有提供数学计算的单体内置对象如 Math 对象。</p><h3 id="对json的理解" tabindex="-1">对JSON的理解 <a class="header-anchor" href="#对json的理解" aria-hidden="true">#</a></h3><p>JSON 是一种基于文本的轻量级的数据交换格式。它可以被任何的编程语言读取和作为数据格式来传递。</p><p>在项目开发中，使用 JSON 作为前后端数据交换的方式。在前端通过将一个符合 JSON 格式的数据结构序列化为 JSON 字符串，然后将它传递到后端，后端通过 JSON 格式的字符串解析后生成对应的数据结构，以此来实现前后端数据的一个传递。</p><p>因为 JSON 的语法是基于 js 的，因此很容易将 JSON 和 js 中的对象弄混，但是应该注意的是 JSON 和 js 中的对象不是一回事，JSON 中对象格式更加严格，比如说在 JSON 中属性值不能为函数，不能出现 NaN 这样的属性值等，因此大多数的 js 对象是不符合 JSON 对象的格式的。</p><p>在 js 中提供了两个函数来实现 js 数据结构和 JSON 格式的转换处理，</p><ul><li>JSON.stringify 函数，通过传入一个符合 JSON 格式的数据结构，将其转换为一个 JSON 字符串。如果传入的数据结构不符合 JSON 格式，那么在序列化的时候会对这些值进行对应的特殊处理，使其符合规范。在前端向后端发送数据时，可以调用这个函数将数据对象转化为 JSON 格式的字符串。</li><li>JSON.parse() 函数，这个函数用来将 JSON 格式的字符串转换为一个 js 数据结构，如果传入的字符串不是标准的 JSON 格式的字符串的话，将会抛出错误。当从后端接收到 JSON 格式的字符串时，可以通过这个方法来将其解析为一个 js 数据结构，以此来进行数据的访问。</li></ul><h3 id="为什么函数的-arguments-参数是类数组而不是数组？如何遍历类数组" tabindex="-1">为什么函数的 arguments 参数是类数组而不是数组？如何遍历类数组? <a class="header-anchor" href="#为什么函数的-arguments-参数是类数组而不是数组？如何遍历类数组" aria-hidden="true">#</a></h3><p><code>arguments</code>是一个对象，它的属性是从 0 开始依次递增的数字，还有<code>callee</code>和<code>length</code>等属性，与数组相似；但是它却没有数组常见的方法属性，如<code>forEach</code>, <code>reduce</code>等，所以叫它们类数组。</p><p>要遍历类数组，有三个方法：</p><p>（1）将数组的方法应用到类数组上，这时候就可以使用<code>call</code>和<code>apply</code>方法，如：</p><div class="language-javascript"><pre><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> 
  <span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arguments<span class="token punctuation">,</span> <span class="token parameter">a</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>（2）使用Array.from方法将类数组转化成数组：‌</p><div class="language-javascript"><pre><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> 
  <span class="token keyword">const</span> arrArgs <span class="token operator">=</span> Array<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span> 
  arrArgs<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">a</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>（3）使用展开运算符将类数组转化成数组</p><div class="language-javascript"><pre><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> 
    <span class="token keyword">const</span> arrArgs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>arguments<span class="token punctuation">]</span> 
    arrArgs<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">a</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span> 
<span class="token punctuation">}</span>
</code></pre></div><h3 id="javascript为什么要进行变量提升，它导致了什么问题？" tabindex="-1">JavaScript为什么要进行变量提升，它导致了什么问题？ <a class="header-anchor" href="#javascript为什么要进行变量提升，它导致了什么问题？" aria-hidden="true">#</a></h3><p>变量提升的表现是，无论在函数中何处位置声明的变量，好像都被提升到了函数的首部，可以在变量声明前访问到而不会报错。</p><p>造成变量声明提升的<strong>本质原因</strong>是 js 引擎在代码执行前有一个解析的过程，创建了执行上下文，初始化了一些代码执行时需要用到的对象。当访问一个变量时，会到当前执行上下文中的作用域链中去查找，而作用域链的首端指向的是当前执行上下文的变量对象，这个变量对象是执行上下文的一个属性，它包含了函数的形参、所有的函数和变量声明，这个对象的是在代码解析的时候创建的。</p><p>首先要知道，JS在拿到一个变量或者一个函数的时候，会有两步操作，即解析和执行。</p><ul><li><p>在解析阶段</p><p>，JS会检查语法，并对函数进行预编译。解析的时候会先创建一个全局执行上下文环境，先把代码中即将执行的变量、函数声明都拿出来，变量先赋值为undefined，函数先声明好可使用。在一个函数执行之前，也会创建一个函数执行上下文环境，跟全局执行上下文类似，不过函数执行上下文会多出this、arguments和函数的参数。</p><ul><li>全局上下文：变量定义，函数声明</li><li>函数上下文：变量定义，函数声明，this，arguments</li></ul></li><li><p><strong>在执行阶段</strong>，就是按照代码的顺序依次执行。</p></li></ul><p>那为什么会进行变量提升呢？主要有以下两个原因：</p><ul><li>提高性能</li><li>容错性更好</li></ul><p><strong>（1）提高性能</strong> 在JS代码执行之前，会进行语法检查和预编译，并且这一操作只进行一次。这么做就是为了提高性能，如果没有这一步，那么每次执行代码前都必须重新解析一遍该变量（函数），而这是没有必要的，因为变量（函数）的代码并不会改变，解析一遍就够了。</p><p>在解析的过程中，还会为函数生成预编译代码。在预编译时，会统计声明了哪些变量、创建了哪些函数，并对函数的代码进行压缩，去除注释、不必要的空白等。这样做的好处就是每次执行函数时都可以直接为该函数分配栈空间（不需要再解析一遍去获取代码中声明了哪些变量，创建了哪些函数），并且因为代码压缩的原因，代码执行也更快了。</p><p><strong>（2）容错性更好</strong></p><p>变量提升可以在一定程度上提高JS的容错性，看下面的代码：</p><div class="language-javascript"><pre><code>a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">var</span> a<span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>如果没有变量提升，这两行代码就会报错，但是因为有了变量提升，这段代码就可以正常执行。</p><p>虽然，在可以开发过程中，可以完全避免这样写，但是有时代码很复杂的时候。可能因为疏忽而先使用后定义了，这样也不会影响正常使用。由于变量提升的存在，而会正常运行。</p><p><strong>总结：</strong></p><ul><li>解析和预编译过程中的声明提升可以提高性能，让函数可以在执行时预先为变量分配栈空间</li><li>声明提升还可以提高JS代码的容错性，使一些不规范的代码也可以正常执行</li></ul><p>变量提升虽然有一些优点，但是他也会造成一定的问题，在ES6中提出了let、const来定义变量，它们就没有变量提升的机制。下面看一下变量提升可能会导致的问题：</p><div class="language-javascript"><pre><code><span class="token keyword">var</span> tmp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token keyword">var</span> tmp <span class="token operator">=</span> <span class="token string">&#39;hello world&#39;</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// undefined</span>
</code></pre></div><p>在这个函数中，原本是要打印出外层的tmp变量，但是因为变量提升的问题，内层定义的tmp被提到函数内部的最顶部，相当于覆盖了外层的tmp，所以打印结果为undefined。</p><div class="language-javascript"><pre><code><span class="token keyword">var</span> tmp <span class="token operator">=</span> <span class="token string">&#39;hello world&#39;</span><span class="token punctuation">;</span>

<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> tmp<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>tmp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 11</span>
</code></pre></div><p>由于遍历时定义的i会变量提升成为一个全局变量，在函数结束之后不会被销毁，所以打印出来11。</p><h3 id="for-in和for-of的区别" tabindex="-1">for...in和for...of的区别 <a class="header-anchor" href="#for-in和for-of的区别" aria-hidden="true">#</a></h3><p>for…of 是ES6新增的遍历方式，允许遍历一个含有iterator接口的数据结构（数组、对象等）并且返回各项的值，和ES3中的for…in的区别如下</p><ul><li>for…of 遍历获取的是对象的键值，for…in 获取的是对象的键名；</li><li>for… in 会遍历对象的整个原型链，性能非常差不推荐使用，而 for … of 只遍历当前对象不会遍历原型链；</li><li>对于数组的遍历，for…in 会返回数组中所有可枚举的属性(包括原型链上可枚举的属性)，for…of 只返回数组的下标对应的属性值；</li></ul><p><strong>总结：</strong> for...in 循环主要是为了遍历对象而生，不适用于遍历数组；for...of 循环可以用来遍历数组、类数组对象，字符串、Set、Map 以及 Generator 对象。</p><h3 id="数组的遍历方法有哪些" tabindex="-1">数组的遍历方法有哪些 <a class="header-anchor" href="#数组的遍历方法有哪些" aria-hidden="true">#</a></h3><table><thead><tr><th><strong>方法</strong></th><th><strong>是否改变原数组</strong></th><th><strong>特点</strong></th></tr></thead><tbody><tr><td>forEach()</td><td>否</td><td>数组方法，不改变原数组，没有返回值</td></tr><tr><td>map()</td><td>否</td><td>数组方法，不改变原数组，有返回值，可链式调用</td></tr><tr><td>filter()</td><td>否</td><td>数组方法，过滤数组，返回包含符合条件的元素的数组，可链式调用</td></tr><tr><td>for...of</td><td>否</td><td>for...of遍历具有Iterator迭代器的对象的属性，返回的是数组的元素、对象的属性值，不能遍历普通的obj对象，将异步循环变成同步循环</td></tr><tr><td>every() 和 some()</td><td>否</td><td>数组方法，some()只要有一个是true，便返回true；而every()只要有一个是false，便返回false.</td></tr><tr><td>find() 和 findIndex()</td><td>否</td><td>数组方法，find()返回的是第一个符合条件的值；findIndex()返回的是第一个返回条件的值的索引值</td></tr><tr><td>reduce() 和 reduceRight()</td><td>否</td><td>数组方法，reduce()对数组正序操作；reduceRight()对数组逆序操作</td></tr></tbody></table></div></div><footer class="page-footer" data-v-8fcebc32 data-v-5c96fb00><div class="edit" data-v-5c96fb00><div class="edit-link" data-v-5c96fb00 data-v-55695e90><!----></div></div><div class="updated" data-v-5c96fb00><!----></div></footer><!----><!--[--><!--[--><!----><!--]--><!--[--><!----><!--]--><!--]--></div></main></div><!----><!--]--><footer data-v-c1f40558> Copyright © 2019-2022 | MIT License </footer><!--]--></div>
    <script>__VP_HASH_MAP__ = JSON.parse("{\"readme.md\":\"f5fe0545\",\"archives.md\":\"26efe50a\",\"index.md\":\"9a356bbc\",\"posts_ajax.md\":\"c04be746\",\"posts_git.md\":\"beca9a4a\",\"posts_react.md\":\"041077d9\",\"posts_es6模块化.md\":\"b0b4cbc4\",\"posts_npm使用手册.md\":\"e0d01f9e\",\"posts_npm命令发生的事.md\":\"d314ef4c\",\"posts_vue3快速上手.md\":\"b8f332b6\",\"posts_wechat-01.md\":\"36fa7e59\",\"posts_wechat-02.md\":\"a9bfa25b\",\"posts_wechat-03.md\":\"934603e1\",\"posts_wechat-04.md\":\"75aca085\",\"posts_wechat-05.md\":\"4090255a\",\"posts_前端三件套面试题.md\":\"06e57df2\",\"posts_前端常见面试题总结.md\":\"57bb51e1\",\"posts_前端面试题之浏览器原理篇摘自语雀.md\":\"4c507996\",\"posts_吴雨豪面试题详解.md\":\"a2376c6d\",\"posts_微信小程序封装请求响应拦截器.md\":\"4bb0a376\",\"posts_第二次面试问题.md\":\"23a81ba8\",\"posts_面试题(精简).md\":\"cccbc0d4\",\"posts_面试题之css篇摘自语雀.md\":\"76a2a59b\",\"posts_面试题之javascript篇摘自语雀.md\":\"a6e58da0\",\"posts_面试题之vue篇摘自语雀.md\":\"f381bf8a\",\"posts_面试题之性能优化篇.md\":\"d7f503fb\",\"tags.md\":\"0332bb26\"}")</script>
    <script type="module" async src="/KBLOG_2/assets/app.d3efa65c.js"></script>
    
  </body>
</html>